import {
  BaseGameScene
} from "./chunk-QM267PUW.js";
import {
  AnimatedSprite,
  Application,
  Assets,
  Text
} from "./chunk-OIB5BCIZ.js";
import "./chunk-RDIZOUOA.js";
import {
  Graphics,
  LoaderParserPriority,
  path
} from "./chunk-YEUTNKQ3.js";
import "./chunk-4QKVGCG7.js";
import "./chunk-ZELRMNHO.js";
import "./chunk-IQ6BEMM5.js";
import "./chunk-O6RFZS5S.js";
import {
  Container,
  DOMAdapter,
  ExtensionType,
  Ticker,
  eventemitter3_default,
  extensions
} from "./chunk-BTTYRXG3.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/signals/dist/signals.js
var require_signals = __commonJS({
  "node_modules/signals/dist/signals.js"(exports, module) {
    (function(global2) {
      function SignalBinding(signal, listener, isOnce, listenerContext, priority) {
        this._listener = listener;
        this._isOnce = isOnce;
        this.context = listenerContext;
        this._signal = signal;
        this._priority = priority || 0;
      }
      SignalBinding.prototype = {
        /**
         * If binding is active and should be executed.
         * @type boolean
         */
        active: true,
        /**
         * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute`. (curried parameters)
         * @type Array|null
         */
        params: null,
        /**
         * Call listener passing arbitrary parameters.
         * <p>If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.</p>
         * @param {Array} [paramsArr] Array of parameters that should be passed to the listener
         * @return {*} Value returned by the listener.
         */
        execute: function(paramsArr) {
          var handlerReturn, params;
          if (this.active && !!this._listener) {
            params = this.params ? this.params.concat(paramsArr) : paramsArr;
            handlerReturn = this._listener.apply(this.context, params);
            if (this._isOnce) {
              this.detach();
            }
          }
          return handlerReturn;
        },
        /**
         * Detach binding from signal.
         * - alias to: mySignal.remove(myBinding.getListener());
         * @return {Function|null} Handler function bound to the signal or `null` if binding was previously detached.
         */
        detach: function() {
          return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
        },
        /**
         * @return {Boolean} `true` if binding is still bound to the signal and have a listener.
         */
        isBound: function() {
          return !!this._signal && !!this._listener;
        },
        /**
         * @return {boolean} If SignalBinding will only be executed once.
         */
        isOnce: function() {
          return this._isOnce;
        },
        /**
         * @return {Function} Handler function bound to the signal.
         */
        getListener: function() {
          return this._listener;
        },
        /**
         * @return {Signal} Signal that listener is currently bound to.
         */
        getSignal: function() {
          return this._signal;
        },
        /**
         * Delete instance properties
         * @private
         */
        _destroy: function() {
          delete this._signal;
          delete this._listener;
          delete this.context;
        },
        /**
         * @return {string} String representation of the object.
         */
        toString: function() {
          return "[SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]";
        }
      };
      function validateListener(listener, fnName) {
        if (typeof listener !== "function") {
          throw new Error("listener is a required param of {fn}() and should be a Function.".replace("{fn}", fnName));
        }
      }
      function Signal2() {
        this._bindings = [];
        this._prevParams = null;
        var self = this;
        this.dispatch = function() {
          Signal2.prototype.dispatch.apply(self, arguments);
        };
      }
      Signal2.prototype = {
        /**
         * Signals Version Number
         * @type String
         * @const
         */
        VERSION: "1.0.0",
        /**
         * If Signal should keep record of previously dispatched parameters and
         * automatically execute listener during `add()`/`addOnce()` if Signal was
         * already dispatched before.
         * @type boolean
         */
        memorize: false,
        /**
         * @type boolean
         * @private
         */
        _shouldPropagate: true,
        /**
         * If Signal is active and should broadcast events.
         * <p><strong>IMPORTANT:</strong> Setting this property during a dispatch will only affect the next dispatch, if you want to stop the propagation of a signal use `halt()` instead.</p>
         * @type boolean
         */
        active: true,
        /**
         * @param {Function} listener
         * @param {boolean} isOnce
         * @param {Object} [listenerContext]
         * @param {Number} [priority]
         * @return {SignalBinding}
         * @private
         */
        _registerListener: function(listener, isOnce, listenerContext, priority) {
          var prevIndex = this._indexOfListener(listener, listenerContext), binding;
          if (prevIndex !== -1) {
            binding = this._bindings[prevIndex];
            if (binding.isOnce() !== isOnce) {
              throw new Error("You cannot add" + (isOnce ? "" : "Once") + "() then add" + (!isOnce ? "" : "Once") + "() the same listener without removing the relationship first.");
            }
          } else {
            binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);
            this._addBinding(binding);
          }
          if (this.memorize && this._prevParams) {
            binding.execute(this._prevParams);
          }
          return binding;
        },
        /**
         * @param {SignalBinding} binding
         * @private
         */
        _addBinding: function(binding) {
          var n = this._bindings.length;
          do {
            --n;
          } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
          this._bindings.splice(n + 1, 0, binding);
        },
        /**
         * @param {Function} listener
         * @return {number}
         * @private
         */
        _indexOfListener: function(listener, context) {
          var n = this._bindings.length, cur;
          while (n--) {
            cur = this._bindings[n];
            if (cur._listener === listener && cur.context === context) {
              return n;
            }
          }
          return -1;
        },
        /**
         * Check if listener was attached to Signal.
         * @param {Function} listener
         * @param {Object} [context]
         * @return {boolean} if Signal has the specified listener.
         */
        has: function(listener, context) {
          return this._indexOfListener(listener, context) !== -1;
        },
        /**
         * Add a listener to the signal.
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        add: function(listener, listenerContext, priority) {
          validateListener(listener, "add");
          return this._registerListener(listener, false, listenerContext, priority);
        },
        /**
         * Add listener to the signal that should be removed after first execution (will be executed only once).
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        addOnce: function(listener, listenerContext, priority) {
          validateListener(listener, "addOnce");
          return this._registerListener(listener, true, listenerContext, priority);
        },
        /**
         * Remove a single listener from the dispatch queue.
         * @param {Function} listener Handler function that should be removed.
         * @param {Object} [context] Execution context (since you can add the same handler multiple times if executing in a different context).
         * @return {Function} Listener handler function.
         */
        remove: function(listener, context) {
          validateListener(listener, "remove");
          var i = this._indexOfListener(listener, context);
          if (i !== -1) {
            this._bindings[i]._destroy();
            this._bindings.splice(i, 1);
          }
          return listener;
        },
        /**
         * Remove all listeners from the Signal.
         */
        removeAll: function() {
          var n = this._bindings.length;
          while (n--) {
            this._bindings[n]._destroy();
          }
          this._bindings.length = 0;
        },
        /**
         * @return {number} Number of listeners attached to the Signal.
         */
        getNumListeners: function() {
          return this._bindings.length;
        },
        /**
         * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
         * <p><strong>IMPORTANT:</strong> should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.</p>
         * @see Signal.prototype.disable
         */
        halt: function() {
          this._shouldPropagate = false;
        },
        /**
         * Dispatch/Broadcast Signal to all listeners added to the queue.
         * @param {...*} [params] Parameters that should be passed to each handler.
         */
        dispatch: function(params) {
          if (!this.active) {
            return;
          }
          var paramsArr = Array.prototype.slice.call(arguments), n = this._bindings.length, bindings;
          if (this.memorize) {
            this._prevParams = paramsArr;
          }
          if (!n) {
            return;
          }
          bindings = this._bindings.slice();
          this._shouldPropagate = true;
          do {
            n--;
          } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        },
        /**
         * Forget memorized arguments.
         * @see Signal.memorize
         */
        forget: function() {
          this._prevParams = null;
        },
        /**
         * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).
         * <p><strong>IMPORTANT:</strong> calling any method on the signal instance after calling dispose will throw errors.</p>
         */
        dispose: function() {
          this.removeAll();
          delete this._bindings;
          delete this._prevParams;
        },
        /**
         * @return {string} String representation of the object.
         */
        toString: function() {
          return "[Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]";
        }
      };
      var signals = Signal2;
      signals.Signal = Signal2;
      if (typeof define === "function" && define.amd) {
        define(function() {
          return signals;
        });
      } else if (typeof module !== "undefined" && module.exports) {
        module.exports = signals;
      } else {
        global2["signals"] = signals;
      }
    })(exports);
  }
});

// node_modules/howler/dist/howler.js
var require_howler = __commonJS({
  "node_modules/howler/dist/howler.js"(exports) {
    (function() {
      "use strict";
      var HowlerGlobal2 = function() {
        this.init();
      };
      HowlerGlobal2.prototype = {
        /**
         * Initialize the global Howler object.
         * @return {Howler}
         */
        init: function() {
          var self = this || Howler2;
          self._counter = 1e3;
          self._html5AudioPool = [];
          self.html5PoolSize = 10;
          self._codecs = {};
          self._howls = [];
          self._muted = false;
          self._volume = 1;
          self._canPlayEvent = "canplaythrough";
          self._navigator = typeof window !== "undefined" && window.navigator ? window.navigator : null;
          self.masterGain = null;
          self.noAudio = false;
          self.usingWebAudio = true;
          self.autoSuspend = true;
          self.ctx = null;
          self.autoUnlock = true;
          self._setup();
          return self;
        },
        /**
         * Get/set the global volume for all sounds.
         * @param  {Float} vol Volume from 0.0 to 1.0.
         * @return {Howler/Float}     Returns self or current volume.
         */
        volume: function(vol) {
          var self = this || Howler2;
          vol = parseFloat(vol);
          if (!self.ctx) {
            setupAudioContext();
          }
          if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
            self._volume = vol;
            if (self._muted) {
              return self;
            }
            if (self.usingWebAudio) {
              self.masterGain.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
            }
            for (var i = 0; i < self._howls.length; i++) {
              if (!self._howls[i]._webAudio) {
                var ids = self._howls[i]._getSoundIds();
                for (var j = 0; j < ids.length; j++) {
                  var sound2 = self._howls[i]._soundById(ids[j]);
                  if (sound2 && sound2._node) {
                    sound2._node.volume = sound2._volume * vol;
                  }
                }
              }
            }
            return self;
          }
          return self._volume;
        },
        /**
         * Handle muting and unmuting globally.
         * @param  {Boolean} muted Is muted or not.
         */
        mute: function(muted) {
          var self = this || Howler2;
          if (!self.ctx) {
            setupAudioContext();
          }
          self._muted = muted;
          if (self.usingWebAudio) {
            self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler2.ctx.currentTime);
          }
          for (var i = 0; i < self._howls.length; i++) {
            if (!self._howls[i]._webAudio) {
              var ids = self._howls[i]._getSoundIds();
              for (var j = 0; j < ids.length; j++) {
                var sound2 = self._howls[i]._soundById(ids[j]);
                if (sound2 && sound2._node) {
                  sound2._node.muted = muted ? true : sound2._muted;
                }
              }
            }
          }
          return self;
        },
        /**
         * Handle stopping all sounds globally.
         */
        stop: function() {
          var self = this || Howler2;
          for (var i = 0; i < self._howls.length; i++) {
            self._howls[i].stop();
          }
          return self;
        },
        /**
         * Unload and destroy all currently loaded Howl objects.
         * @return {Howler}
         */
        unload: function() {
          var self = this || Howler2;
          for (var i = self._howls.length - 1; i >= 0; i--) {
            self._howls[i].unload();
          }
          if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== "undefined") {
            self.ctx.close();
            self.ctx = null;
            setupAudioContext();
          }
          return self;
        },
        /**
         * Check for codec support of specific extension.
         * @param  {String} ext Audio file extention.
         * @return {Boolean}
         */
        codecs: function(ext) {
          return (this || Howler2)._codecs[ext.replace(/^x-/, "")];
        },
        /**
         * Setup various state values for global tracking.
         * @return {Howler}
         */
        _setup: function() {
          var self = this || Howler2;
          self.state = self.ctx ? self.ctx.state || "suspended" : "suspended";
          self._autoSuspend();
          if (!self.usingWebAudio) {
            if (typeof Audio !== "undefined") {
              try {
                var test = new Audio();
                if (typeof test.oncanplaythrough === "undefined") {
                  self._canPlayEvent = "canplay";
                }
              } catch (e) {
                self.noAudio = true;
              }
            } else {
              self.noAudio = true;
            }
          }
          try {
            var test = new Audio();
            if (test.muted) {
              self.noAudio = true;
            }
          } catch (e) {
          }
          if (!self.noAudio) {
            self._setupCodecs();
          }
          return self;
        },
        /**
         * Check for browser support for various codecs and cache the results.
         * @return {Howler}
         */
        _setupCodecs: function() {
          var self = this || Howler2;
          var audioTest = null;
          try {
            audioTest = typeof Audio !== "undefined" ? new Audio() : null;
          } catch (err) {
            return self;
          }
          if (!audioTest || typeof audioTest.canPlayType !== "function") {
            return self;
          }
          var mpegTest = audioTest.canPlayType("audio/mpeg;").replace(/^no$/, "");
          var ua = self._navigator ? self._navigator.userAgent : "";
          var checkOpera = ua.match(/OPR\/(\d+)/g);
          var isOldOpera = checkOpera && parseInt(checkOpera[0].split("/")[1], 10) < 33;
          var checkSafari = ua.indexOf("Safari") !== -1 && ua.indexOf("Chrome") === -1;
          var safariVersion = ua.match(/Version\/(.*?) /);
          var isOldSafari = checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15;
          self._codecs = {
            mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType("audio/mp3;").replace(/^no$/, ""))),
            mpeg: !!mpegTest,
            opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
            ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
            oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
            wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType("audio/wav")).replace(/^no$/, ""),
            aac: !!audioTest.canPlayType("audio/aac;").replace(/^no$/, ""),
            caf: !!audioTest.canPlayType("audio/x-caf;").replace(/^no$/, ""),
            m4a: !!(audioTest.canPlayType("audio/x-m4a;") || audioTest.canPlayType("audio/m4a;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
            m4b: !!(audioTest.canPlayType("audio/x-m4b;") || audioTest.canPlayType("audio/m4b;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
            mp4: !!(audioTest.canPlayType("audio/x-mp4;") || audioTest.canPlayType("audio/mp4;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
            weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
            webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
            dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
            flac: !!(audioTest.canPlayType("audio/x-flac;") || audioTest.canPlayType("audio/flac;")).replace(/^no$/, "")
          };
          return self;
        },
        /**
         * Some browsers/devices will only allow audio to be played after a user interaction.
         * Attempt to automatically unlock audio on the first user interaction.
         * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
         * @return {Howler}
         */
        _unlockAudio: function() {
          var self = this || Howler2;
          if (self._audioUnlocked || !self.ctx) {
            return;
          }
          self._audioUnlocked = false;
          self.autoUnlock = false;
          if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
            self._mobileUnloaded = true;
            self.unload();
          }
          self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);
          var unlock = function(e) {
            while (self._html5AudioPool.length < self.html5PoolSize) {
              try {
                var audioNode = new Audio();
                audioNode._unlocked = true;
                self._releaseHtml5Audio(audioNode);
              } catch (e2) {
                self.noAudio = true;
                break;
              }
            }
            for (var i = 0; i < self._howls.length; i++) {
              if (!self._howls[i]._webAudio) {
                var ids = self._howls[i]._getSoundIds();
                for (var j = 0; j < ids.length; j++) {
                  var sound2 = self._howls[i]._soundById(ids[j]);
                  if (sound2 && sound2._node && !sound2._node._unlocked) {
                    sound2._node._unlocked = true;
                    sound2._node.load();
                  }
                }
              }
            }
            self._autoResume();
            var source = self.ctx.createBufferSource();
            source.buffer = self._scratchBuffer;
            source.connect(self.ctx.destination);
            if (typeof source.start === "undefined") {
              source.noteOn(0);
            } else {
              source.start(0);
            }
            if (typeof self.ctx.resume === "function") {
              self.ctx.resume();
            }
            source.onended = function() {
              source.disconnect(0);
              self._audioUnlocked = true;
              document.removeEventListener("touchstart", unlock, true);
              document.removeEventListener("touchend", unlock, true);
              document.removeEventListener("click", unlock, true);
              document.removeEventListener("keydown", unlock, true);
              for (var i2 = 0; i2 < self._howls.length; i2++) {
                self._howls[i2]._emit("unlock");
              }
            };
          };
          document.addEventListener("touchstart", unlock, true);
          document.addEventListener("touchend", unlock, true);
          document.addEventListener("click", unlock, true);
          document.addEventListener("keydown", unlock, true);
          return self;
        },
        /**
         * Get an unlocked HTML5 Audio object from the pool. If none are left,
         * return a new Audio object and throw a warning.
         * @return {Audio} HTML5 Audio object.
         */
        _obtainHtml5Audio: function() {
          var self = this || Howler2;
          if (self._html5AudioPool.length) {
            return self._html5AudioPool.pop();
          }
          var testPlay = new Audio().play();
          if (testPlay && typeof Promise !== "undefined" && (testPlay instanceof Promise || typeof testPlay.then === "function")) {
            testPlay.catch(function() {
              console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
            });
          }
          return new Audio();
        },
        /**
         * Return an activated HTML5 Audio object to the pool.
         * @return {Howler}
         */
        _releaseHtml5Audio: function(audio) {
          var self = this || Howler2;
          if (audio._unlocked) {
            self._html5AudioPool.push(audio);
          }
          return self;
        },
        /**
         * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
         * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
         * @return {Howler}
         */
        _autoSuspend: function() {
          var self = this;
          if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === "undefined" || !Howler2.usingWebAudio) {
            return;
          }
          for (var i = 0; i < self._howls.length; i++) {
            if (self._howls[i]._webAudio) {
              for (var j = 0; j < self._howls[i]._sounds.length; j++) {
                if (!self._howls[i]._sounds[j]._paused) {
                  return self;
                }
              }
            }
          }
          if (self._suspendTimer) {
            clearTimeout(self._suspendTimer);
          }
          self._suspendTimer = setTimeout(function() {
            if (!self.autoSuspend) {
              return;
            }
            self._suspendTimer = null;
            self.state = "suspending";
            var handleSuspension = function() {
              self.state = "suspended";
              if (self._resumeAfterSuspend) {
                delete self._resumeAfterSuspend;
                self._autoResume();
              }
            };
            self.ctx.suspend().then(handleSuspension, handleSuspension);
          }, 3e4);
          return self;
        },
        /**
         * Automatically resume the Web Audio AudioContext when a new sound is played.
         * @return {Howler}
         */
        _autoResume: function() {
          var self = this;
          if (!self.ctx || typeof self.ctx.resume === "undefined" || !Howler2.usingWebAudio) {
            return;
          }
          if (self.state === "running" && self.ctx.state !== "interrupted" && self._suspendTimer) {
            clearTimeout(self._suspendTimer);
            self._suspendTimer = null;
          } else if (self.state === "suspended" || self.state === "running" && self.ctx.state === "interrupted") {
            self.ctx.resume().then(function() {
              self.state = "running";
              for (var i = 0; i < self._howls.length; i++) {
                self._howls[i]._emit("resume");
              }
            });
            if (self._suspendTimer) {
              clearTimeout(self._suspendTimer);
              self._suspendTimer = null;
            }
          } else if (self.state === "suspending") {
            self._resumeAfterSuspend = true;
          }
          return self;
        }
      };
      var Howler2 = new HowlerGlobal2();
      var Howl3 = function(o) {
        var self = this;
        if (!o.src || o.src.length === 0) {
          console.error("An array of source files must be passed with any new Howl.");
          return;
        }
        self.init(o);
      };
      Howl3.prototype = {
        /**
         * Initialize a new Howl group object.
         * @param  {Object} o Passed in properties for this group.
         * @return {Howl}
         */
        init: function(o) {
          var self = this;
          if (!Howler2.ctx) {
            setupAudioContext();
          }
          self._autoplay = o.autoplay || false;
          self._format = typeof o.format !== "string" ? o.format : [o.format];
          self._html5 = o.html5 || false;
          self._muted = o.mute || false;
          self._loop = o.loop || false;
          self._pool = o.pool || 5;
          self._preload = typeof o.preload === "boolean" || o.preload === "metadata" ? o.preload : true;
          self._rate = o.rate || 1;
          self._sprite = o.sprite || {};
          self._src = typeof o.src !== "string" ? o.src : [o.src];
          self._volume = o.volume !== void 0 ? o.volume : 1;
          self._xhr = {
            method: o.xhr && o.xhr.method ? o.xhr.method : "GET",
            headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
            withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false
          };
          self._duration = 0;
          self._state = "unloaded";
          self._sounds = [];
          self._endTimers = {};
          self._queue = [];
          self._playLock = false;
          self._onend = o.onend ? [{ fn: o.onend }] : [];
          self._onfade = o.onfade ? [{ fn: o.onfade }] : [];
          self._onload = o.onload ? [{ fn: o.onload }] : [];
          self._onloaderror = o.onloaderror ? [{ fn: o.onloaderror }] : [];
          self._onplayerror = o.onplayerror ? [{ fn: o.onplayerror }] : [];
          self._onpause = o.onpause ? [{ fn: o.onpause }] : [];
          self._onplay = o.onplay ? [{ fn: o.onplay }] : [];
          self._onstop = o.onstop ? [{ fn: o.onstop }] : [];
          self._onmute = o.onmute ? [{ fn: o.onmute }] : [];
          self._onvolume = o.onvolume ? [{ fn: o.onvolume }] : [];
          self._onrate = o.onrate ? [{ fn: o.onrate }] : [];
          self._onseek = o.onseek ? [{ fn: o.onseek }] : [];
          self._onunlock = o.onunlock ? [{ fn: o.onunlock }] : [];
          self._onresume = [];
          self._webAudio = Howler2.usingWebAudio && !self._html5;
          if (typeof Howler2.ctx !== "undefined" && Howler2.ctx && Howler2.autoUnlock) {
            Howler2._unlockAudio();
          }
          Howler2._howls.push(self);
          if (self._autoplay) {
            self._queue.push({
              event: "play",
              action: function() {
                self.play();
              }
            });
          }
          if (self._preload && self._preload !== "none") {
            self.load();
          }
          return self;
        },
        /**
         * Load the audio file.
         * @return {Howler}
         */
        load: function() {
          var self = this;
          var url = null;
          if (Howler2.noAudio) {
            self._emit("loaderror", null, "No audio support.");
            return;
          }
          if (typeof self._src === "string") {
            self._src = [self._src];
          }
          for (var i = 0; i < self._src.length; i++) {
            var ext, str;
            if (self._format && self._format[i]) {
              ext = self._format[i];
            } else {
              str = self._src[i];
              if (typeof str !== "string") {
                self._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                continue;
              }
              ext = /^data:audio\/([^;,]+);/i.exec(str);
              if (!ext) {
                ext = /\.([^.]+)$/.exec(str.split("?", 1)[0]);
              }
              if (ext) {
                ext = ext[1].toLowerCase();
              }
            }
            if (!ext) {
              console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
            }
            if (ext && Howler2.codecs(ext)) {
              url = self._src[i];
              break;
            }
          }
          if (!url) {
            self._emit("loaderror", null, "No codec support for selected audio sources.");
            return;
          }
          self._src = url;
          self._state = "loading";
          if (window.location.protocol === "https:" && url.slice(0, 5) === "http:") {
            self._html5 = true;
            self._webAudio = false;
          }
          new Sound3(self);
          if (self._webAudio) {
            loadBuffer(self);
          }
          return self;
        },
        /**
         * Play a sound or resume previous playback.
         * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
         * @param  {Boolean} internal Internal Use: true prevents event firing.
         * @return {Number}          Sound ID.
         */
        play: function(sprite, internal) {
          var self = this;
          var id3 = null;
          if (typeof sprite === "number") {
            id3 = sprite;
            sprite = null;
          } else if (typeof sprite === "string" && self._state === "loaded" && !self._sprite[sprite]) {
            return null;
          } else if (typeof sprite === "undefined") {
            sprite = "__default";
            if (!self._playLock) {
              var num = 0;
              for (var i = 0; i < self._sounds.length; i++) {
                if (self._sounds[i]._paused && !self._sounds[i]._ended) {
                  num++;
                  id3 = self._sounds[i]._id;
                }
              }
              if (num === 1) {
                sprite = null;
              } else {
                id3 = null;
              }
            }
          }
          var sound2 = id3 ? self._soundById(id3) : self._inactiveSound();
          if (!sound2) {
            return null;
          }
          if (id3 && !sprite) {
            sprite = sound2._sprite || "__default";
          }
          if (self._state !== "loaded") {
            sound2._sprite = sprite;
            sound2._ended = false;
            var soundId = sound2._id;
            self._queue.push({
              event: "play",
              action: function() {
                self.play(soundId);
              }
            });
            return soundId;
          }
          if (id3 && !sound2._paused) {
            if (!internal) {
              self._loadQueue("play");
            }
            return sound2._id;
          }
          if (self._webAudio) {
            Howler2._autoResume();
          }
          var seek = Math.max(0, sound2._seek > 0 ? sound2._seek : self._sprite[sprite][0] / 1e3);
          var duration = Math.max(0, (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1e3 - seek);
          var timeout = duration * 1e3 / Math.abs(sound2._rate);
          var start = self._sprite[sprite][0] / 1e3;
          var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1e3;
          sound2._sprite = sprite;
          sound2._ended = false;
          var setParams = function() {
            sound2._paused = false;
            sound2._seek = seek;
            sound2._start = start;
            sound2._stop = stop;
            sound2._loop = !!(sound2._loop || self._sprite[sprite][2]);
          };
          if (seek >= stop) {
            self._ended(sound2);
            return;
          }
          var node = sound2._node;
          if (self._webAudio) {
            var playWebAudio = function() {
              self._playLock = false;
              setParams();
              self._refreshBuffer(sound2);
              var vol = sound2._muted || self._muted ? 0 : sound2._volume;
              node.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
              sound2._playStart = Howler2.ctx.currentTime;
              if (typeof node.bufferSource.start === "undefined") {
                sound2._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
              } else {
                sound2._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
              }
              if (timeout !== Infinity) {
                self._endTimers[sound2._id] = setTimeout(self._ended.bind(self, sound2), timeout);
              }
              if (!internal) {
                setTimeout(function() {
                  self._emit("play", sound2._id);
                  self._loadQueue();
                }, 0);
              }
            };
            if (Howler2.state === "running" && Howler2.ctx.state !== "interrupted") {
              playWebAudio();
            } else {
              self._playLock = true;
              self.once("resume", playWebAudio);
              self._clearTimer(sound2._id);
            }
          } else {
            var playHtml5 = function() {
              node.currentTime = seek;
              node.muted = sound2._muted || self._muted || Howler2._muted || node.muted;
              node.volume = sound2._volume * Howler2.volume();
              node.playbackRate = sound2._rate;
              try {
                var play = node.play();
                if (play && typeof Promise !== "undefined" && (play instanceof Promise || typeof play.then === "function")) {
                  self._playLock = true;
                  setParams();
                  play.then(function() {
                    self._playLock = false;
                    node._unlocked = true;
                    if (!internal) {
                      self._emit("play", sound2._id);
                    } else {
                      self._loadQueue();
                    }
                  }).catch(function() {
                    self._playLock = false;
                    self._emit("playerror", sound2._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                    sound2._ended = true;
                    sound2._paused = true;
                  });
                } else if (!internal) {
                  self._playLock = false;
                  setParams();
                  self._emit("play", sound2._id);
                }
                node.playbackRate = sound2._rate;
                if (node.paused) {
                  self._emit("playerror", sound2._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                  return;
                }
                if (sprite !== "__default" || sound2._loop) {
                  self._endTimers[sound2._id] = setTimeout(self._ended.bind(self, sound2), timeout);
                } else {
                  self._endTimers[sound2._id] = function() {
                    self._ended(sound2);
                    node.removeEventListener("ended", self._endTimers[sound2._id], false);
                  };
                  node.addEventListener("ended", self._endTimers[sound2._id], false);
                }
              } catch (err) {
                self._emit("playerror", sound2._id, err);
              }
            };
            if (node.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA") {
              node.src = self._src;
              node.load();
            }
            var loadedNoReadyState = window && window.ejecta || !node.readyState && Howler2._navigator.isCocoonJS;
            if (node.readyState >= 3 || loadedNoReadyState) {
              playHtml5();
            } else {
              self._playLock = true;
              self._state = "loading";
              var listener = function() {
                self._state = "loaded";
                playHtml5();
                node.removeEventListener(Howler2._canPlayEvent, listener, false);
              };
              node.addEventListener(Howler2._canPlayEvent, listener, false);
              self._clearTimer(sound2._id);
            }
          }
          return sound2._id;
        },
        /**
         * Pause playback and save current position.
         * @param  {Number} id The sound ID (empty to pause all in group).
         * @return {Howl}
         */
        pause: function(id3) {
          var self = this;
          if (self._state !== "loaded" || self._playLock) {
            self._queue.push({
              event: "pause",
              action: function() {
                self.pause(id3);
              }
            });
            return self;
          }
          var ids = self._getSoundIds(id3);
          for (var i = 0; i < ids.length; i++) {
            self._clearTimer(ids[i]);
            var sound2 = self._soundById(ids[i]);
            if (sound2 && !sound2._paused) {
              sound2._seek = self.seek(ids[i]);
              sound2._rateSeek = 0;
              sound2._paused = true;
              self._stopFade(ids[i]);
              if (sound2._node) {
                if (self._webAudio) {
                  if (!sound2._node.bufferSource) {
                    continue;
                  }
                  if (typeof sound2._node.bufferSource.stop === "undefined") {
                    sound2._node.bufferSource.noteOff(0);
                  } else {
                    sound2._node.bufferSource.stop(0);
                  }
                  self._cleanBuffer(sound2._node);
                } else if (!isNaN(sound2._node.duration) || sound2._node.duration === Infinity) {
                  sound2._node.pause();
                }
              }
            }
            if (!arguments[1]) {
              self._emit("pause", sound2 ? sound2._id : null);
            }
          }
          return self;
        },
        /**
         * Stop playback and reset to start.
         * @param  {Number} id The sound ID (empty to stop all in group).
         * @param  {Boolean} internal Internal Use: true prevents event firing.
         * @return {Howl}
         */
        stop: function(id3, internal) {
          var self = this;
          if (self._state !== "loaded" || self._playLock) {
            self._queue.push({
              event: "stop",
              action: function() {
                self.stop(id3);
              }
            });
            return self;
          }
          var ids = self._getSoundIds(id3);
          for (var i = 0; i < ids.length; i++) {
            self._clearTimer(ids[i]);
            var sound2 = self._soundById(ids[i]);
            if (sound2) {
              sound2._seek = sound2._start || 0;
              sound2._rateSeek = 0;
              sound2._paused = true;
              sound2._ended = true;
              self._stopFade(ids[i]);
              if (sound2._node) {
                if (self._webAudio) {
                  if (sound2._node.bufferSource) {
                    if (typeof sound2._node.bufferSource.stop === "undefined") {
                      sound2._node.bufferSource.noteOff(0);
                    } else {
                      sound2._node.bufferSource.stop(0);
                    }
                    self._cleanBuffer(sound2._node);
                  }
                } else if (!isNaN(sound2._node.duration) || sound2._node.duration === Infinity) {
                  sound2._node.currentTime = sound2._start || 0;
                  sound2._node.pause();
                  if (sound2._node.duration === Infinity) {
                    self._clearSound(sound2._node);
                  }
                }
              }
              if (!internal) {
                self._emit("stop", sound2._id);
              }
            }
          }
          return self;
        },
        /**
         * Mute/unmute a single sound or all sounds in this Howl group.
         * @param  {Boolean} muted Set to true to mute and false to unmute.
         * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
         * @return {Howl}
         */
        mute: function(muted, id3) {
          var self = this;
          if (self._state !== "loaded" || self._playLock) {
            self._queue.push({
              event: "mute",
              action: function() {
                self.mute(muted, id3);
              }
            });
            return self;
          }
          if (typeof id3 === "undefined") {
            if (typeof muted === "boolean") {
              self._muted = muted;
            } else {
              return self._muted;
            }
          }
          var ids = self._getSoundIds(id3);
          for (var i = 0; i < ids.length; i++) {
            var sound2 = self._soundById(ids[i]);
            if (sound2) {
              sound2._muted = muted;
              if (sound2._interval) {
                self._stopFade(sound2._id);
              }
              if (self._webAudio && sound2._node) {
                sound2._node.gain.setValueAtTime(muted ? 0 : sound2._volume, Howler2.ctx.currentTime);
              } else if (sound2._node) {
                sound2._node.muted = Howler2._muted ? true : muted;
              }
              self._emit("mute", sound2._id);
            }
          }
          return self;
        },
        /**
         * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
         *   volume() -> Returns the group's volume value.
         *   volume(id) -> Returns the sound id's current volume.
         *   volume(vol) -> Sets the volume of all sounds in this Howl group.
         *   volume(vol, id) -> Sets the volume of passed sound id.
         * @return {Howl/Number} Returns self or current volume.
         */
        volume: function() {
          var self = this;
          var args = arguments;
          var vol, id3;
          if (args.length === 0) {
            return self._volume;
          } else if (args.length === 1 || args.length === 2 && typeof args[1] === "undefined") {
            var ids = self._getSoundIds();
            var index = ids.indexOf(args[0]);
            if (index >= 0) {
              id3 = parseInt(args[0], 10);
            } else {
              vol = parseFloat(args[0]);
            }
          } else if (args.length >= 2) {
            vol = parseFloat(args[0]);
            id3 = parseInt(args[1], 10);
          }
          var sound2;
          if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
            if (self._state !== "loaded" || self._playLock) {
              self._queue.push({
                event: "volume",
                action: function() {
                  self.volume.apply(self, args);
                }
              });
              return self;
            }
            if (typeof id3 === "undefined") {
              self._volume = vol;
            }
            id3 = self._getSoundIds(id3);
            for (var i = 0; i < id3.length; i++) {
              sound2 = self._soundById(id3[i]);
              if (sound2) {
                sound2._volume = vol;
                if (!args[2]) {
                  self._stopFade(id3[i]);
                }
                if (self._webAudio && sound2._node && !sound2._muted) {
                  sound2._node.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
                } else if (sound2._node && !sound2._muted) {
                  sound2._node.volume = vol * Howler2.volume();
                }
                self._emit("volume", sound2._id);
              }
            }
          } else {
            sound2 = id3 ? self._soundById(id3) : self._sounds[0];
            return sound2 ? sound2._volume : 0;
          }
          return self;
        },
        /**
         * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
         * @param  {Number} from The value to fade from (0.0 to 1.0).
         * @param  {Number} to   The volume to fade to (0.0 to 1.0).
         * @param  {Number} len  Time in milliseconds to fade.
         * @param  {Number} id   The sound id (omit to fade all sounds).
         * @return {Howl}
         */
        fade: function(from, to, len, id3) {
          var self = this;
          if (self._state !== "loaded" || self._playLock) {
            self._queue.push({
              event: "fade",
              action: function() {
                self.fade(from, to, len, id3);
              }
            });
            return self;
          }
          from = Math.min(Math.max(0, parseFloat(from)), 1);
          to = Math.min(Math.max(0, parseFloat(to)), 1);
          len = parseFloat(len);
          self.volume(from, id3);
          var ids = self._getSoundIds(id3);
          for (var i = 0; i < ids.length; i++) {
            var sound2 = self._soundById(ids[i]);
            if (sound2) {
              if (!id3) {
                self._stopFade(ids[i]);
              }
              if (self._webAudio && !sound2._muted) {
                var currentTime = Howler2.ctx.currentTime;
                var end = currentTime + len / 1e3;
                sound2._volume = from;
                sound2._node.gain.setValueAtTime(from, currentTime);
                sound2._node.gain.linearRampToValueAtTime(to, end);
              }
              self._startFadeInterval(sound2, from, to, len, ids[i], typeof id3 === "undefined");
            }
          }
          return self;
        },
        /**
         * Starts the internal interval to fade a sound.
         * @param  {Object} sound Reference to sound to fade.
         * @param  {Number} from The value to fade from (0.0 to 1.0).
         * @param  {Number} to   The volume to fade to (0.0 to 1.0).
         * @param  {Number} len  Time in milliseconds to fade.
         * @param  {Number} id   The sound id to fade.
         * @param  {Boolean} isGroup   If true, set the volume on the group.
         */
        _startFadeInterval: function(sound2, from, to, len, id3, isGroup) {
          var self = this;
          var vol = from;
          var diff = to - from;
          var steps = Math.abs(diff / 0.01);
          var stepLen = Math.max(4, steps > 0 ? len / steps : len);
          var lastTick = Date.now();
          sound2._fadeTo = to;
          sound2._interval = setInterval(function() {
            var tick = (Date.now() - lastTick) / len;
            lastTick = Date.now();
            vol += diff * tick;
            vol = Math.round(vol * 100) / 100;
            if (diff < 0) {
              vol = Math.max(to, vol);
            } else {
              vol = Math.min(to, vol);
            }
            if (self._webAudio) {
              sound2._volume = vol;
            } else {
              self.volume(vol, sound2._id, true);
            }
            if (isGroup) {
              self._volume = vol;
            }
            if (to < from && vol <= to || to > from && vol >= to) {
              clearInterval(sound2._interval);
              sound2._interval = null;
              sound2._fadeTo = null;
              self.volume(to, sound2._id);
              self._emit("fade", sound2._id);
            }
          }, stepLen);
        },
        /**
         * Internal method that stops the currently playing fade when
         * a new fade starts, volume is changed or the sound is stopped.
         * @param  {Number} id The sound id.
         * @return {Howl}
         */
        _stopFade: function(id3) {
          var self = this;
          var sound2 = self._soundById(id3);
          if (sound2 && sound2._interval) {
            if (self._webAudio) {
              sound2._node.gain.cancelScheduledValues(Howler2.ctx.currentTime);
            }
            clearInterval(sound2._interval);
            sound2._interval = null;
            self.volume(sound2._fadeTo, id3);
            sound2._fadeTo = null;
            self._emit("fade", id3);
          }
          return self;
        },
        /**
         * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
         *   loop() -> Returns the group's loop value.
         *   loop(id) -> Returns the sound id's loop value.
         *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
         *   loop(loop, id) -> Sets the loop value of passed sound id.
         * @return {Howl/Boolean} Returns self or current loop value.
         */
        loop: function() {
          var self = this;
          var args = arguments;
          var loop, id3, sound2;
          if (args.length === 0) {
            return self._loop;
          } else if (args.length === 1) {
            if (typeof args[0] === "boolean") {
              loop = args[0];
              self._loop = loop;
            } else {
              sound2 = self._soundById(parseInt(args[0], 10));
              return sound2 ? sound2._loop : false;
            }
          } else if (args.length === 2) {
            loop = args[0];
            id3 = parseInt(args[1], 10);
          }
          var ids = self._getSoundIds(id3);
          for (var i = 0; i < ids.length; i++) {
            sound2 = self._soundById(ids[i]);
            if (sound2) {
              sound2._loop = loop;
              if (self._webAudio && sound2._node && sound2._node.bufferSource) {
                sound2._node.bufferSource.loop = loop;
                if (loop) {
                  sound2._node.bufferSource.loopStart = sound2._start || 0;
                  sound2._node.bufferSource.loopEnd = sound2._stop;
                  if (self.playing(ids[i])) {
                    self.pause(ids[i], true);
                    self.play(ids[i], true);
                  }
                }
              }
            }
          }
          return self;
        },
        /**
         * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
         *   rate() -> Returns the first sound node's current playback rate.
         *   rate(id) -> Returns the sound id's current playback rate.
         *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
         *   rate(rate, id) -> Sets the playback rate of passed sound id.
         * @return {Howl/Number} Returns self or the current playback rate.
         */
        rate: function() {
          var self = this;
          var args = arguments;
          var rate, id3;
          if (args.length === 0) {
            id3 = self._sounds[0]._id;
          } else if (args.length === 1) {
            var ids = self._getSoundIds();
            var index = ids.indexOf(args[0]);
            if (index >= 0) {
              id3 = parseInt(args[0], 10);
            } else {
              rate = parseFloat(args[0]);
            }
          } else if (args.length === 2) {
            rate = parseFloat(args[0]);
            id3 = parseInt(args[1], 10);
          }
          var sound2;
          if (typeof rate === "number") {
            if (self._state !== "loaded" || self._playLock) {
              self._queue.push({
                event: "rate",
                action: function() {
                  self.rate.apply(self, args);
                }
              });
              return self;
            }
            if (typeof id3 === "undefined") {
              self._rate = rate;
            }
            id3 = self._getSoundIds(id3);
            for (var i = 0; i < id3.length; i++) {
              sound2 = self._soundById(id3[i]);
              if (sound2) {
                if (self.playing(id3[i])) {
                  sound2._rateSeek = self.seek(id3[i]);
                  sound2._playStart = self._webAudio ? Howler2.ctx.currentTime : sound2._playStart;
                }
                sound2._rate = rate;
                if (self._webAudio && sound2._node && sound2._node.bufferSource) {
                  sound2._node.bufferSource.playbackRate.setValueAtTime(rate, Howler2.ctx.currentTime);
                } else if (sound2._node) {
                  sound2._node.playbackRate = rate;
                }
                var seek = self.seek(id3[i]);
                var duration = (self._sprite[sound2._sprite][0] + self._sprite[sound2._sprite][1]) / 1e3 - seek;
                var timeout = duration * 1e3 / Math.abs(sound2._rate);
                if (self._endTimers[id3[i]] || !sound2._paused) {
                  self._clearTimer(id3[i]);
                  self._endTimers[id3[i]] = setTimeout(self._ended.bind(self, sound2), timeout);
                }
                self._emit("rate", sound2._id);
              }
            }
          } else {
            sound2 = self._soundById(id3);
            return sound2 ? sound2._rate : self._rate;
          }
          return self;
        },
        /**
         * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
         *   seek() -> Returns the first sound node's current seek position.
         *   seek(id) -> Returns the sound id's current seek position.
         *   seek(seek) -> Sets the seek position of the first sound node.
         *   seek(seek, id) -> Sets the seek position of passed sound id.
         * @return {Howl/Number} Returns self or the current seek position.
         */
        seek: function() {
          var self = this;
          var args = arguments;
          var seek, id3;
          if (args.length === 0) {
            if (self._sounds.length) {
              id3 = self._sounds[0]._id;
            }
          } else if (args.length === 1) {
            var ids = self._getSoundIds();
            var index = ids.indexOf(args[0]);
            if (index >= 0) {
              id3 = parseInt(args[0], 10);
            } else if (self._sounds.length) {
              id3 = self._sounds[0]._id;
              seek = parseFloat(args[0]);
            }
          } else if (args.length === 2) {
            seek = parseFloat(args[0]);
            id3 = parseInt(args[1], 10);
          }
          if (typeof id3 === "undefined") {
            return 0;
          }
          if (typeof seek === "number" && (self._state !== "loaded" || self._playLock)) {
            self._queue.push({
              event: "seek",
              action: function() {
                self.seek.apply(self, args);
              }
            });
            return self;
          }
          var sound2 = self._soundById(id3);
          if (sound2) {
            if (typeof seek === "number" && seek >= 0) {
              var playing = self.playing(id3);
              if (playing) {
                self.pause(id3, true);
              }
              sound2._seek = seek;
              sound2._ended = false;
              self._clearTimer(id3);
              if (!self._webAudio && sound2._node && !isNaN(sound2._node.duration)) {
                sound2._node.currentTime = seek;
              }
              var seekAndEmit = function() {
                if (playing) {
                  self.play(id3, true);
                }
                self._emit("seek", id3);
              };
              if (playing && !self._webAudio) {
                var emitSeek = function() {
                  if (!self._playLock) {
                    seekAndEmit();
                  } else {
                    setTimeout(emitSeek, 0);
                  }
                };
                setTimeout(emitSeek, 0);
              } else {
                seekAndEmit();
              }
            } else {
              if (self._webAudio) {
                var realTime = self.playing(id3) ? Howler2.ctx.currentTime - sound2._playStart : 0;
                var rateSeek = sound2._rateSeek ? sound2._rateSeek - sound2._seek : 0;
                return sound2._seek + (rateSeek + realTime * Math.abs(sound2._rate));
              } else {
                return sound2._node.currentTime;
              }
            }
          }
          return self;
        },
        /**
         * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
         * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
         * @return {Boolean} True if playing and false if not.
         */
        playing: function(id3) {
          var self = this;
          if (typeof id3 === "number") {
            var sound2 = self._soundById(id3);
            return sound2 ? !sound2._paused : false;
          }
          for (var i = 0; i < self._sounds.length; i++) {
            if (!self._sounds[i]._paused) {
              return true;
            }
          }
          return false;
        },
        /**
         * Get the duration of this sound. Passing a sound id will return the sprite duration.
         * @param  {Number} id The sound id to check. If none is passed, return full source duration.
         * @return {Number} Audio duration in seconds.
         */
        duration: function(id3) {
          var self = this;
          var duration = self._duration;
          var sound2 = self._soundById(id3);
          if (sound2) {
            duration = self._sprite[sound2._sprite][1] / 1e3;
          }
          return duration;
        },
        /**
         * Returns the current loaded state of this Howl.
         * @return {String} 'unloaded', 'loading', 'loaded'
         */
        state: function() {
          return this._state;
        },
        /**
         * Unload and destroy the current Howl object.
         * This will immediately stop all sound instances attached to this group.
         */
        unload: function() {
          var self = this;
          var sounds = self._sounds;
          for (var i = 0; i < sounds.length; i++) {
            if (!sounds[i]._paused) {
              self.stop(sounds[i]._id);
            }
            if (!self._webAudio) {
              self._clearSound(sounds[i]._node);
              sounds[i]._node.removeEventListener("error", sounds[i]._errorFn, false);
              sounds[i]._node.removeEventListener(Howler2._canPlayEvent, sounds[i]._loadFn, false);
              sounds[i]._node.removeEventListener("ended", sounds[i]._endFn, false);
              Howler2._releaseHtml5Audio(sounds[i]._node);
            }
            delete sounds[i]._node;
            self._clearTimer(sounds[i]._id);
          }
          var index = Howler2._howls.indexOf(self);
          if (index >= 0) {
            Howler2._howls.splice(index, 1);
          }
          var remCache = true;
          for (i = 0; i < Howler2._howls.length; i++) {
            if (Howler2._howls[i]._src === self._src || self._src.indexOf(Howler2._howls[i]._src) >= 0) {
              remCache = false;
              break;
            }
          }
          if (cache && remCache) {
            delete cache[self._src];
          }
          Howler2.noAudio = false;
          self._state = "unloaded";
          self._sounds = [];
          self = null;
          return null;
        },
        /**
         * Listen to a custom event.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to call.
         * @param  {Number}   id    (optional) Only listen to events for this sound.
         * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
         * @return {Howl}
         */
        on: function(event, fn, id3, once) {
          var self = this;
          var events = self["_on" + event];
          if (typeof fn === "function") {
            events.push(once ? { id: id3, fn, once } : { id: id3, fn });
          }
          return self;
        },
        /**
         * Remove a custom event. Call without parameters to remove all events.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to remove. Leave empty to remove all.
         * @param  {Number}   id    (optional) Only remove events for this sound.
         * @return {Howl}
         */
        off: function(event, fn, id3) {
          var self = this;
          var events = self["_on" + event];
          var i = 0;
          if (typeof fn === "number") {
            id3 = fn;
            fn = null;
          }
          if (fn || id3) {
            for (i = 0; i < events.length; i++) {
              var isId = id3 === events[i].id;
              if (fn === events[i].fn && isId || !fn && isId) {
                events.splice(i, 1);
                break;
              }
            }
          } else if (event) {
            self["_on" + event] = [];
          } else {
            var keys = Object.keys(self);
            for (i = 0; i < keys.length; i++) {
              if (keys[i].indexOf("_on") === 0 && Array.isArray(self[keys[i]])) {
                self[keys[i]] = [];
              }
            }
          }
          return self;
        },
        /**
         * Listen to a custom event and remove it once fired.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to call.
         * @param  {Number}   id    (optional) Only listen to events for this sound.
         * @return {Howl}
         */
        once: function(event, fn, id3) {
          var self = this;
          self.on(event, fn, id3, 1);
          return self;
        },
        /**
         * Emit all events of a specific type and pass the sound id.
         * @param  {String} event Event name.
         * @param  {Number} id    Sound ID.
         * @param  {Number} msg   Message to go with event.
         * @return {Howl}
         */
        _emit: function(event, id3, msg) {
          var self = this;
          var events = self["_on" + event];
          for (var i = events.length - 1; i >= 0; i--) {
            if (!events[i].id || events[i].id === id3 || event === "load") {
              setTimeout((function(fn) {
                fn.call(this, id3, msg);
              }).bind(self, events[i].fn), 0);
              if (events[i].once) {
                self.off(event, events[i].fn, events[i].id);
              }
            }
          }
          self._loadQueue(event);
          return self;
        },
        /**
         * Queue of actions initiated before the sound has loaded.
         * These will be called in sequence, with the next only firing
         * after the previous has finished executing (even if async like play).
         * @return {Howl}
         */
        _loadQueue: function(event) {
          var self = this;
          if (self._queue.length > 0) {
            var task = self._queue[0];
            if (task.event === event) {
              self._queue.shift();
              self._loadQueue();
            }
            if (!event) {
              task.action();
            }
          }
          return self;
        },
        /**
         * Fired when playback ends at the end of the duration.
         * @param  {Sound} sound The sound object to work with.
         * @return {Howl}
         */
        _ended: function(sound2) {
          var self = this;
          var sprite = sound2._sprite;
          if (!self._webAudio && sound2._node && !sound2._node.paused && !sound2._node.ended && sound2._node.currentTime < sound2._stop) {
            setTimeout(self._ended.bind(self, sound2), 100);
            return self;
          }
          var loop = !!(sound2._loop || self._sprite[sprite][2]);
          self._emit("end", sound2._id);
          if (!self._webAudio && loop) {
            self.stop(sound2._id, true).play(sound2._id);
          }
          if (self._webAudio && loop) {
            self._emit("play", sound2._id);
            sound2._seek = sound2._start || 0;
            sound2._rateSeek = 0;
            sound2._playStart = Howler2.ctx.currentTime;
            var timeout = (sound2._stop - sound2._start) * 1e3 / Math.abs(sound2._rate);
            self._endTimers[sound2._id] = setTimeout(self._ended.bind(self, sound2), timeout);
          }
          if (self._webAudio && !loop) {
            sound2._paused = true;
            sound2._ended = true;
            sound2._seek = sound2._start || 0;
            sound2._rateSeek = 0;
            self._clearTimer(sound2._id);
            self._cleanBuffer(sound2._node);
            Howler2._autoSuspend();
          }
          if (!self._webAudio && !loop) {
            self.stop(sound2._id, true);
          }
          return self;
        },
        /**
         * Clear the end timer for a sound playback.
         * @param  {Number} id The sound ID.
         * @return {Howl}
         */
        _clearTimer: function(id3) {
          var self = this;
          if (self._endTimers[id3]) {
            if (typeof self._endTimers[id3] !== "function") {
              clearTimeout(self._endTimers[id3]);
            } else {
              var sound2 = self._soundById(id3);
              if (sound2 && sound2._node) {
                sound2._node.removeEventListener("ended", self._endTimers[id3], false);
              }
            }
            delete self._endTimers[id3];
          }
          return self;
        },
        /**
         * Return the sound identified by this ID, or return null.
         * @param  {Number} id Sound ID
         * @return {Object}    Sound object or null.
         */
        _soundById: function(id3) {
          var self = this;
          for (var i = 0; i < self._sounds.length; i++) {
            if (id3 === self._sounds[i]._id) {
              return self._sounds[i];
            }
          }
          return null;
        },
        /**
         * Return an inactive sound from the pool or create a new one.
         * @return {Sound} Sound playback object.
         */
        _inactiveSound: function() {
          var self = this;
          self._drain();
          for (var i = 0; i < self._sounds.length; i++) {
            if (self._sounds[i]._ended) {
              return self._sounds[i].reset();
            }
          }
          return new Sound3(self);
        },
        /**
         * Drain excess inactive sounds from the pool.
         */
        _drain: function() {
          var self = this;
          var limit = self._pool;
          var cnt = 0;
          var i = 0;
          if (self._sounds.length < limit) {
            return;
          }
          for (i = 0; i < self._sounds.length; i++) {
            if (self._sounds[i]._ended) {
              cnt++;
            }
          }
          for (i = self._sounds.length - 1; i >= 0; i--) {
            if (cnt <= limit) {
              return;
            }
            if (self._sounds[i]._ended) {
              if (self._webAudio && self._sounds[i]._node) {
                self._sounds[i]._node.disconnect(0);
              }
              self._sounds.splice(i, 1);
              cnt--;
            }
          }
        },
        /**
         * Get all ID's from the sounds pool.
         * @param  {Number} id Only return one ID if one is passed.
         * @return {Array}    Array of IDs.
         */
        _getSoundIds: function(id3) {
          var self = this;
          if (typeof id3 === "undefined") {
            var ids = [];
            for (var i = 0; i < self._sounds.length; i++) {
              ids.push(self._sounds[i]._id);
            }
            return ids;
          } else {
            return [id3];
          }
        },
        /**
         * Load the sound back into the buffer source.
         * @param  {Sound} sound The sound object to work with.
         * @return {Howl}
         */
        _refreshBuffer: function(sound2) {
          var self = this;
          sound2._node.bufferSource = Howler2.ctx.createBufferSource();
          sound2._node.bufferSource.buffer = cache[self._src];
          if (sound2._panner) {
            sound2._node.bufferSource.connect(sound2._panner);
          } else {
            sound2._node.bufferSource.connect(sound2._node);
          }
          sound2._node.bufferSource.loop = sound2._loop;
          if (sound2._loop) {
            sound2._node.bufferSource.loopStart = sound2._start || 0;
            sound2._node.bufferSource.loopEnd = sound2._stop || 0;
          }
          sound2._node.bufferSource.playbackRate.setValueAtTime(sound2._rate, Howler2.ctx.currentTime);
          return self;
        },
        /**
         * Prevent memory leaks by cleaning up the buffer source after playback.
         * @param  {Object} node Sound's audio node containing the buffer source.
         * @return {Howl}
         */
        _cleanBuffer: function(node) {
          var self = this;
          var isIOS = Howler2._navigator && Howler2._navigator.vendor.indexOf("Apple") >= 0;
          if (!node.bufferSource) {
            return self;
          }
          if (Howler2._scratchBuffer && node.bufferSource) {
            node.bufferSource.onended = null;
            node.bufferSource.disconnect(0);
            if (isIOS) {
              try {
                node.bufferSource.buffer = Howler2._scratchBuffer;
              } catch (e) {
              }
            }
          }
          node.bufferSource = null;
          return self;
        },
        /**
         * Set the source to a 0-second silence to stop any downloading (except in IE).
         * @param  {Object} node Audio node to clear.
         */
        _clearSound: function(node) {
          var checkIE = /MSIE |Trident\//.test(Howler2._navigator && Howler2._navigator.userAgent);
          if (!checkIE) {
            node.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA";
          }
        }
      };
      var Sound3 = function(howl) {
        this._parent = howl;
        this.init();
      };
      Sound3.prototype = {
        /**
         * Initialize a new Sound object.
         * @return {Sound}
         */
        init: function() {
          var self = this;
          var parent = self._parent;
          self._muted = parent._muted;
          self._loop = parent._loop;
          self._volume = parent._volume;
          self._rate = parent._rate;
          self._seek = 0;
          self._paused = true;
          self._ended = true;
          self._sprite = "__default";
          self._id = ++Howler2._counter;
          parent._sounds.push(self);
          self.create();
          return self;
        },
        /**
         * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
         * @return {Sound}
         */
        create: function() {
          var self = this;
          var parent = self._parent;
          var volume = Howler2._muted || self._muted || self._parent._muted ? 0 : self._volume;
          if (parent._webAudio) {
            self._node = typeof Howler2.ctx.createGain === "undefined" ? Howler2.ctx.createGainNode() : Howler2.ctx.createGain();
            self._node.gain.setValueAtTime(volume, Howler2.ctx.currentTime);
            self._node.paused = true;
            self._node.connect(Howler2.masterGain);
          } else if (!Howler2.noAudio) {
            self._node = Howler2._obtainHtml5Audio();
            self._errorFn = self._errorListener.bind(self);
            self._node.addEventListener("error", self._errorFn, false);
            self._loadFn = self._loadListener.bind(self);
            self._node.addEventListener(Howler2._canPlayEvent, self._loadFn, false);
            self._endFn = self._endListener.bind(self);
            self._node.addEventListener("ended", self._endFn, false);
            self._node.src = parent._src;
            self._node.preload = parent._preload === true ? "auto" : parent._preload;
            self._node.volume = volume * Howler2.volume();
            self._node.load();
          }
          return self;
        },
        /**
         * Reset the parameters of this sound to the original state (for recycle).
         * @return {Sound}
         */
        reset: function() {
          var self = this;
          var parent = self._parent;
          self._muted = parent._muted;
          self._loop = parent._loop;
          self._volume = parent._volume;
          self._rate = parent._rate;
          self._seek = 0;
          self._rateSeek = 0;
          self._paused = true;
          self._ended = true;
          self._sprite = "__default";
          self._id = ++Howler2._counter;
          return self;
        },
        /**
         * HTML5 Audio error listener callback.
         */
        _errorListener: function() {
          var self = this;
          self._parent._emit("loaderror", self._id, self._node.error ? self._node.error.code : 0);
          self._node.removeEventListener("error", self._errorFn, false);
        },
        /**
         * HTML5 Audio canplaythrough listener callback.
         */
        _loadListener: function() {
          var self = this;
          var parent = self._parent;
          parent._duration = Math.ceil(self._node.duration * 10) / 10;
          if (Object.keys(parent._sprite).length === 0) {
            parent._sprite = { __default: [0, parent._duration * 1e3] };
          }
          if (parent._state !== "loaded") {
            parent._state = "loaded";
            parent._emit("load");
            parent._loadQueue();
          }
          self._node.removeEventListener(Howler2._canPlayEvent, self._loadFn, false);
        },
        /**
         * HTML5 Audio ended listener callback.
         */
        _endListener: function() {
          var self = this;
          var parent = self._parent;
          if (parent._duration === Infinity) {
            parent._duration = Math.ceil(self._node.duration * 10) / 10;
            if (parent._sprite.__default[1] === Infinity) {
              parent._sprite.__default[1] = parent._duration * 1e3;
            }
            parent._ended(self);
          }
          self._node.removeEventListener("ended", self._endFn, false);
        }
      };
      var cache = {};
      var loadBuffer = function(self) {
        var url = self._src;
        if (cache[url]) {
          self._duration = cache[url].duration;
          loadSound(self);
          return;
        }
        if (/^data:[^;]+;base64,/.test(url)) {
          var data = atob(url.split(",")[1]);
          var dataView = new Uint8Array(data.length);
          for (var i = 0; i < data.length; ++i) {
            dataView[i] = data.charCodeAt(i);
          }
          decodeAudioData(dataView.buffer, self);
        } else {
          var xhr = new XMLHttpRequest();
          xhr.open(self._xhr.method, url, true);
          xhr.withCredentials = self._xhr.withCredentials;
          xhr.responseType = "arraybuffer";
          if (self._xhr.headers) {
            Object.keys(self._xhr.headers).forEach(function(key) {
              xhr.setRequestHeader(key, self._xhr.headers[key]);
            });
          }
          xhr.onload = function() {
            var code = (xhr.status + "")[0];
            if (code !== "0" && code !== "2" && code !== "3") {
              self._emit("loaderror", null, "Failed loading audio file with status: " + xhr.status + ".");
              return;
            }
            decodeAudioData(xhr.response, self);
          };
          xhr.onerror = function() {
            if (self._webAudio) {
              self._html5 = true;
              self._webAudio = false;
              self._sounds = [];
              delete cache[url];
              self.load();
            }
          };
          safeXhrSend(xhr);
        }
      };
      var safeXhrSend = function(xhr) {
        try {
          xhr.send();
        } catch (e) {
          xhr.onerror();
        }
      };
      var decodeAudioData = function(arraybuffer, self) {
        var error = function() {
          self._emit("loaderror", null, "Decoding audio data failed.");
        };
        var success = function(buffer) {
          if (buffer && self._sounds.length > 0) {
            cache[self._src] = buffer;
            loadSound(self, buffer);
          } else {
            error();
          }
        };
        if (typeof Promise !== "undefined" && Howler2.ctx.decodeAudioData.length === 1) {
          Howler2.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
        } else {
          Howler2.ctx.decodeAudioData(arraybuffer, success, error);
        }
      };
      var loadSound = function(self, buffer) {
        if (buffer && !self._duration) {
          self._duration = buffer.duration;
        }
        if (Object.keys(self._sprite).length === 0) {
          self._sprite = { __default: [0, self._duration * 1e3] };
        }
        if (self._state !== "loaded") {
          self._state = "loaded";
          self._emit("load");
          self._loadQueue();
        }
      };
      var setupAudioContext = function() {
        if (!Howler2.usingWebAudio) {
          return;
        }
        try {
          if (typeof AudioContext !== "undefined") {
            Howler2.ctx = new AudioContext();
          } else if (typeof webkitAudioContext !== "undefined") {
            Howler2.ctx = new webkitAudioContext();
          } else {
            Howler2.usingWebAudio = false;
          }
        } catch (e) {
          Howler2.usingWebAudio = false;
        }
        if (!Howler2.ctx) {
          Howler2.usingWebAudio = false;
        }
        var iOS = /iP(hone|od|ad)/.test(Howler2._navigator && Howler2._navigator.platform);
        var appVersion = Howler2._navigator && Howler2._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
        var version = appVersion ? parseInt(appVersion[1], 10) : null;
        if (iOS && version && version < 9) {
          var safari = /safari/.test(Howler2._navigator && Howler2._navigator.userAgent.toLowerCase());
          if (Howler2._navigator && !safari) {
            Howler2.usingWebAudio = false;
          }
        }
        if (Howler2.usingWebAudio) {
          Howler2.masterGain = typeof Howler2.ctx.createGain === "undefined" ? Howler2.ctx.createGainNode() : Howler2.ctx.createGain();
          Howler2.masterGain.gain.setValueAtTime(Howler2._muted ? 0 : Howler2._volume, Howler2.ctx.currentTime);
          Howler2.masterGain.connect(Howler2.ctx.destination);
        }
        Howler2._setup();
      };
      if (typeof define === "function" && define.amd) {
        define([], function() {
          return {
            Howler: Howler2,
            Howl: Howl3
          };
        });
      }
      if (typeof exports !== "undefined") {
        exports.Howler = Howler2;
        exports.Howl = Howl3;
      }
      if (typeof global !== "undefined") {
        global.HowlerGlobal = HowlerGlobal2;
        global.Howler = Howler2;
        global.Howl = Howl3;
        global.Sound = Sound3;
      } else if (typeof window !== "undefined") {
        window.HowlerGlobal = HowlerGlobal2;
        window.Howler = Howler2;
        window.Howl = Howl3;
        window.Sound = Sound3;
      }
    })();
    (function() {
      "use strict";
      HowlerGlobal.prototype._pos = [0, 0, 0];
      HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];
      HowlerGlobal.prototype.stereo = function(pan) {
        var self = this;
        if (!self.ctx || !self.ctx.listener) {
          return self;
        }
        for (var i = self._howls.length - 1; i >= 0; i--) {
          self._howls[i].stereo(pan);
        }
        return self;
      };
      HowlerGlobal.prototype.pos = function(x, y, z) {
        var self = this;
        if (!self.ctx || !self.ctx.listener) {
          return self;
        }
        y = typeof y !== "number" ? self._pos[1] : y;
        z = typeof z !== "number" ? self._pos[2] : z;
        if (typeof x === "number") {
          self._pos = [x, y, z];
          if (typeof self.ctx.listener.positionX !== "undefined") {
            self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);
            self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);
            self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);
          } else {
            self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
          }
        } else {
          return self._pos;
        }
        return self;
      };
      HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
        var self = this;
        if (!self.ctx || !self.ctx.listener) {
          return self;
        }
        var or = self._orientation;
        y = typeof y !== "number" ? or[1] : y;
        z = typeof z !== "number" ? or[2] : z;
        xUp = typeof xUp !== "number" ? or[3] : xUp;
        yUp = typeof yUp !== "number" ? or[4] : yUp;
        zUp = typeof zUp !== "number" ? or[5] : zUp;
        if (typeof x === "number") {
          self._orientation = [x, y, z, xUp, yUp, zUp];
          if (typeof self.ctx.listener.forwardX !== "undefined") {
            self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
            self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
            self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
            self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
            self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
            self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
          } else {
            self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
          }
        } else {
          return or;
        }
        return self;
      };
      Howl.prototype.init = /* @__PURE__ */ function(_super) {
        return function(o) {
          var self = this;
          self._orientation = o.orientation || [1, 0, 0];
          self._stereo = o.stereo || null;
          self._pos = o.pos || null;
          self._pannerAttr = {
            coneInnerAngle: typeof o.coneInnerAngle !== "undefined" ? o.coneInnerAngle : 360,
            coneOuterAngle: typeof o.coneOuterAngle !== "undefined" ? o.coneOuterAngle : 360,
            coneOuterGain: typeof o.coneOuterGain !== "undefined" ? o.coneOuterGain : 0,
            distanceModel: typeof o.distanceModel !== "undefined" ? o.distanceModel : "inverse",
            maxDistance: typeof o.maxDistance !== "undefined" ? o.maxDistance : 1e4,
            panningModel: typeof o.panningModel !== "undefined" ? o.panningModel : "HRTF",
            refDistance: typeof o.refDistance !== "undefined" ? o.refDistance : 1,
            rolloffFactor: typeof o.rolloffFactor !== "undefined" ? o.rolloffFactor : 1
          };
          self._onstereo = o.onstereo ? [{ fn: o.onstereo }] : [];
          self._onpos = o.onpos ? [{ fn: o.onpos }] : [];
          self._onorientation = o.onorientation ? [{ fn: o.onorientation }] : [];
          return _super.call(this, o);
        };
      }(Howl.prototype.init);
      Howl.prototype.stereo = function(pan, id3) {
        var self = this;
        if (!self._webAudio) {
          return self;
        }
        if (self._state !== "loaded") {
          self._queue.push({
            event: "stereo",
            action: function() {
              self.stereo(pan, id3);
            }
          });
          return self;
        }
        var pannerType = typeof Howler.ctx.createStereoPanner === "undefined" ? "spatial" : "stereo";
        if (typeof id3 === "undefined") {
          if (typeof pan === "number") {
            self._stereo = pan;
            self._pos = [pan, 0, 0];
          } else {
            return self._stereo;
          }
        }
        var ids = self._getSoundIds(id3);
        for (var i = 0; i < ids.length; i++) {
          var sound2 = self._soundById(ids[i]);
          if (sound2) {
            if (typeof pan === "number") {
              sound2._stereo = pan;
              sound2._pos = [pan, 0, 0];
              if (sound2._node) {
                sound2._pannerAttr.panningModel = "equalpower";
                if (!sound2._panner || !sound2._panner.pan) {
                  setupPanner(sound2, pannerType);
                }
                if (pannerType === "spatial") {
                  if (typeof sound2._panner.positionX !== "undefined") {
                    sound2._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                    sound2._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                    sound2._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
                  } else {
                    sound2._panner.setPosition(pan, 0, 0);
                  }
                } else {
                  sound2._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
                }
              }
              self._emit("stereo", sound2._id);
            } else {
              return sound2._stereo;
            }
          }
        }
        return self;
      };
      Howl.prototype.pos = function(x, y, z, id3) {
        var self = this;
        if (!self._webAudio) {
          return self;
        }
        if (self._state !== "loaded") {
          self._queue.push({
            event: "pos",
            action: function() {
              self.pos(x, y, z, id3);
            }
          });
          return self;
        }
        y = typeof y !== "number" ? 0 : y;
        z = typeof z !== "number" ? -0.5 : z;
        if (typeof id3 === "undefined") {
          if (typeof x === "number") {
            self._pos = [x, y, z];
          } else {
            return self._pos;
          }
        }
        var ids = self._getSoundIds(id3);
        for (var i = 0; i < ids.length; i++) {
          var sound2 = self._soundById(ids[i]);
          if (sound2) {
            if (typeof x === "number") {
              sound2._pos = [x, y, z];
              if (sound2._node) {
                if (!sound2._panner || sound2._panner.pan) {
                  setupPanner(sound2, "spatial");
                }
                if (typeof sound2._panner.positionX !== "undefined") {
                  sound2._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
                  sound2._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
                  sound2._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
                } else {
                  sound2._panner.setPosition(x, y, z);
                }
              }
              self._emit("pos", sound2._id);
            } else {
              return sound2._pos;
            }
          }
        }
        return self;
      };
      Howl.prototype.orientation = function(x, y, z, id3) {
        var self = this;
        if (!self._webAudio) {
          return self;
        }
        if (self._state !== "loaded") {
          self._queue.push({
            event: "orientation",
            action: function() {
              self.orientation(x, y, z, id3);
            }
          });
          return self;
        }
        y = typeof y !== "number" ? self._orientation[1] : y;
        z = typeof z !== "number" ? self._orientation[2] : z;
        if (typeof id3 === "undefined") {
          if (typeof x === "number") {
            self._orientation = [x, y, z];
          } else {
            return self._orientation;
          }
        }
        var ids = self._getSoundIds(id3);
        for (var i = 0; i < ids.length; i++) {
          var sound2 = self._soundById(ids[i]);
          if (sound2) {
            if (typeof x === "number") {
              sound2._orientation = [x, y, z];
              if (sound2._node) {
                if (!sound2._panner) {
                  if (!sound2._pos) {
                    sound2._pos = self._pos || [0, 0, -0.5];
                  }
                  setupPanner(sound2, "spatial");
                }
                if (typeof sound2._panner.orientationX !== "undefined") {
                  sound2._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
                  sound2._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
                  sound2._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
                } else {
                  sound2._panner.setOrientation(x, y, z);
                }
              }
              self._emit("orientation", sound2._id);
            } else {
              return sound2._orientation;
            }
          }
        }
        return self;
      };
      Howl.prototype.pannerAttr = function() {
        var self = this;
        var args = arguments;
        var o, id3, sound2;
        if (!self._webAudio) {
          return self;
        }
        if (args.length === 0) {
          return self._pannerAttr;
        } else if (args.length === 1) {
          if (typeof args[0] === "object") {
            o = args[0];
            if (typeof id3 === "undefined") {
              if (!o.pannerAttr) {
                o.pannerAttr = {
                  coneInnerAngle: o.coneInnerAngle,
                  coneOuterAngle: o.coneOuterAngle,
                  coneOuterGain: o.coneOuterGain,
                  distanceModel: o.distanceModel,
                  maxDistance: o.maxDistance,
                  refDistance: o.refDistance,
                  rolloffFactor: o.rolloffFactor,
                  panningModel: o.panningModel
                };
              }
              self._pannerAttr = {
                coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== "undefined" ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,
                coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== "undefined" ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,
                coneOuterGain: typeof o.pannerAttr.coneOuterGain !== "undefined" ? o.pannerAttr.coneOuterGain : self._coneOuterGain,
                distanceModel: typeof o.pannerAttr.distanceModel !== "undefined" ? o.pannerAttr.distanceModel : self._distanceModel,
                maxDistance: typeof o.pannerAttr.maxDistance !== "undefined" ? o.pannerAttr.maxDistance : self._maxDistance,
                refDistance: typeof o.pannerAttr.refDistance !== "undefined" ? o.pannerAttr.refDistance : self._refDistance,
                rolloffFactor: typeof o.pannerAttr.rolloffFactor !== "undefined" ? o.pannerAttr.rolloffFactor : self._rolloffFactor,
                panningModel: typeof o.pannerAttr.panningModel !== "undefined" ? o.pannerAttr.panningModel : self._panningModel
              };
            }
          } else {
            sound2 = self._soundById(parseInt(args[0], 10));
            return sound2 ? sound2._pannerAttr : self._pannerAttr;
          }
        } else if (args.length === 2) {
          o = args[0];
          id3 = parseInt(args[1], 10);
        }
        var ids = self._getSoundIds(id3);
        for (var i = 0; i < ids.length; i++) {
          sound2 = self._soundById(ids[i]);
          if (sound2) {
            var pa = sound2._pannerAttr;
            pa = {
              coneInnerAngle: typeof o.coneInnerAngle !== "undefined" ? o.coneInnerAngle : pa.coneInnerAngle,
              coneOuterAngle: typeof o.coneOuterAngle !== "undefined" ? o.coneOuterAngle : pa.coneOuterAngle,
              coneOuterGain: typeof o.coneOuterGain !== "undefined" ? o.coneOuterGain : pa.coneOuterGain,
              distanceModel: typeof o.distanceModel !== "undefined" ? o.distanceModel : pa.distanceModel,
              maxDistance: typeof o.maxDistance !== "undefined" ? o.maxDistance : pa.maxDistance,
              refDistance: typeof o.refDistance !== "undefined" ? o.refDistance : pa.refDistance,
              rolloffFactor: typeof o.rolloffFactor !== "undefined" ? o.rolloffFactor : pa.rolloffFactor,
              panningModel: typeof o.panningModel !== "undefined" ? o.panningModel : pa.panningModel
            };
            var panner = sound2._panner;
            if (!panner) {
              if (!sound2._pos) {
                sound2._pos = self._pos || [0, 0, -0.5];
              }
              setupPanner(sound2, "spatial");
              panner = sound2._panner;
            }
            panner.coneInnerAngle = pa.coneInnerAngle;
            panner.coneOuterAngle = pa.coneOuterAngle;
            panner.coneOuterGain = pa.coneOuterGain;
            panner.distanceModel = pa.distanceModel;
            panner.maxDistance = pa.maxDistance;
            panner.refDistance = pa.refDistance;
            panner.rolloffFactor = pa.rolloffFactor;
            panner.panningModel = pa.panningModel;
          }
        }
        return self;
      };
      Sound.prototype.init = /* @__PURE__ */ function(_super) {
        return function() {
          var self = this;
          var parent = self._parent;
          self._orientation = parent._orientation;
          self._stereo = parent._stereo;
          self._pos = parent._pos;
          self._pannerAttr = parent._pannerAttr;
          _super.call(this);
          if (self._stereo) {
            parent.stereo(self._stereo);
          } else if (self._pos) {
            parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
          }
        };
      }(Sound.prototype.init);
      Sound.prototype.reset = /* @__PURE__ */ function(_super) {
        return function() {
          var self = this;
          var parent = self._parent;
          self._orientation = parent._orientation;
          self._stereo = parent._stereo;
          self._pos = parent._pos;
          self._pannerAttr = parent._pannerAttr;
          if (self._stereo) {
            parent.stereo(self._stereo);
          } else if (self._pos) {
            parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
          } else if (self._panner) {
            self._panner.disconnect(0);
            self._panner = void 0;
            parent._refreshBuffer(self);
          }
          return _super.call(this);
        };
      }(Sound.prototype.reset);
      var setupPanner = function(sound2, type) {
        type = type || "spatial";
        if (type === "spatial") {
          sound2._panner = Howler.ctx.createPanner();
          sound2._panner.coneInnerAngle = sound2._pannerAttr.coneInnerAngle;
          sound2._panner.coneOuterAngle = sound2._pannerAttr.coneOuterAngle;
          sound2._panner.coneOuterGain = sound2._pannerAttr.coneOuterGain;
          sound2._panner.distanceModel = sound2._pannerAttr.distanceModel;
          sound2._panner.maxDistance = sound2._pannerAttr.maxDistance;
          sound2._panner.refDistance = sound2._pannerAttr.refDistance;
          sound2._panner.rolloffFactor = sound2._pannerAttr.rolloffFactor;
          sound2._panner.panningModel = sound2._pannerAttr.panningModel;
          if (typeof sound2._panner.positionX !== "undefined") {
            sound2._panner.positionX.setValueAtTime(sound2._pos[0], Howler.ctx.currentTime);
            sound2._panner.positionY.setValueAtTime(sound2._pos[1], Howler.ctx.currentTime);
            sound2._panner.positionZ.setValueAtTime(sound2._pos[2], Howler.ctx.currentTime);
          } else {
            sound2._panner.setPosition(sound2._pos[0], sound2._pos[1], sound2._pos[2]);
          }
          if (typeof sound2._panner.orientationX !== "undefined") {
            sound2._panner.orientationX.setValueAtTime(sound2._orientation[0], Howler.ctx.currentTime);
            sound2._panner.orientationY.setValueAtTime(sound2._orientation[1], Howler.ctx.currentTime);
            sound2._panner.orientationZ.setValueAtTime(sound2._orientation[2], Howler.ctx.currentTime);
          } else {
            sound2._panner.setOrientation(sound2._orientation[0], sound2._orientation[1], sound2._orientation[2]);
          }
        } else {
          sound2._panner = Howler.ctx.createStereoPanner();
          sound2._panner.pan.setValueAtTime(sound2._stereo, Howler.ctx.currentTime);
        }
        sound2._panner.connect(sound2._node);
        if (!sound2._paused) {
          sound2._parent.pause(sound2._id, true).play(sound2._id, true);
        }
      };
    })();
  }
});

// node_modules/my-pixi-coffee-pixi-game-framework/dist/BaseGameController.js
var BaseGameController = class {
  constructor(gameConfig) {
    this.gameConfig = gameConfig;
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/components/GameScene.js
var GameScene = class extends BaseGameScene {
  constructor(sceneName, container) {
    super(sceneName, container);
    this.gameLabel = new Text("Game Screen", { fill: 16777215, fontSize: 50 });
    this.gameLabel.anchor.set(0.5);
    this.gameLabel.x = 1920 / 2;
    this.gameLabel.y = 1080 / 2;
    this.addChild(this.gameLabel);
  }
  onShow() {
    console.log("GameScene active");
  }
  onHide() {
    console.log("GameScene hidden");
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/components/LoadingScene.js
var LoadingScene = class extends BaseGameScene {
  constructor(sceneName, container) {
    super(sceneName, container);
    this.barWidth = 600;
    this.barHeight = 40;
    const barWidth = 600;
    const barHeight = 40;
    this.progressBar = new Graphics();
    this.progressBar.beginFill(3355443);
    this.progressBar.drawRect(0, 0, barWidth, barHeight);
    this.progressBar.endFill();
    this.progressBar.x = 160;
    this.progressBar.y = 300;
    this.addChild(this.progressBar);
    this.progressFill = new Graphics();
    this.progressFill.beginFill(16777215);
    this.progressFill.drawRect(0, 0, 0, barHeight);
    this.progressFill.endFill();
    this.progressBar.addChild(this.progressFill);
    this.progressText = new Text("Loading 0%", { fill: 16777215, fontSize: 28 });
    this.progressText.x = 400;
    this.progressText.y = 250;
    this.addChild(this.progressText);
  }
  onShow() {
    console.log("LoadingScene active");
  }
  onHide() {
    console.log("LoadingScene hidden");
  }
  updateProgress(progress) {
    console.log("LOADING", progress);
    this.progressFill.clear();
    this.progressFill.beginFill(16777215);
    this.progressFill.drawRect(0, 0, this.barWidth * progress, this.barHeight);
    this.progressFill.endFill();
    this.progressText.text = `Loading ${(progress * 100).toFixed(0)}%`;
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/events/EventBus.js
var import_eventemitter3 = __toESM(require_eventemitter3(), 1);
var eventBus = new import_eventemitter3.default();
var EventBus_default = eventBus;

// node_modules/my-pixi-coffee-pixi-game-framework/dist/components/StartScreen.js
var StartScreen = class extends BaseGameScene {
  constructor(sceneName, container) {
    super(sceneName, container);
    this.startButton = new Graphics();
    this.startButton.beginFill(30719);
    this.startButton.drawRoundedRect(0, 0, 300, 80, 10);
    this.startButton.endFill();
    this.startButton.x = 1920 / 2 - 150;
    this.startButton.y = 1080 / 2 - 40;
    this.startButton.interactive = true;
    this.startButton.cursor = "pointer";
    this.startButton.on("pointerover", () => {
      this.startButton.tint = 43775;
    });
    this.startButton.on("pointerout", () => {
      this.startButton.tint = 16777215;
    });
    this.startButton.on("pointerdown", () => {
      this.onStartClick();
    });
    this.addChild(this.startButton);
    this.startText = new Text("START", { fill: 16777215, fontSize: 36, fontWeight: "bold" });
    this.startText.anchor.set(0.5);
    this.startText.x = this.startButton.x + 150;
    this.startText.y = this.startButton.y + 40;
    this.addChild(this.startText);
  }
  onShow() {
    console.log("StartScreen is active");
  }
  onHide() {
    console.log("StartScreen hidden");
  }
  onStartClick() {
    console.log("Start button clicked!");
    EventBus_default.emit("START_GAME");
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/data/GameComponentsHolder.js
var GameComponentsHolder = class {
  constructor() {
    this.componentsData = /* @__PURE__ */ new Map();
  }
  getComponentsData() {
    return this.componentsData;
  }
  setComponentDatabyId(key, data) {
    this.componentsData.set(key, data);
  }
  getComponentData(key) {
    return this.componentsData.get(key);
  }
  onResize(isLandscape, isMobile, width, height) {
    this.componentsData.forEach((value) => {
      if (value) {
        value.orientationChange(isLandscape, isMobile, width, height);
      }
    });
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/data/GameConfig.js
var GameConfig = class {
  constructor() {
    this.reelsStartX = 0;
    this.reelsStartY = 0;
    this.reelsHolderStartX = 0;
    this.reelsHolderStartY = 0;
    this.symbolWidth = 220;
    this.symbolHeight = 220;
    this.numReels = 5;
    this.numRows = 4;
    this.hasAnticipation = false;
    this.anticipationReels = [];
    this.anticipationTime = 1.2;
    this.spinStopTime = 2;
    this.quickStopSpinTime = 1;
    this.turboStopSpinTime = 0;
    this.spinSpeed = 40;
    this.quickSpinSpeed = 100;
    this.bounceTimeNormal = 0.2;
    this.bounceTimeQuick = 0.1;
    this.reelsStartDelayTime = 0.1;
    this.normalReelStopDelay = 0.3;
    this.quickReelStopDelay = 0.1;
    this.wildID = 0;
    this.scatterId = 0;
    this.springEnd = false;
    this.reelSymbolsID = ["L1_1x1", "L2_1x1", "L3_1x1", "L4_1x1", "H1_1x1", "H2_1x1", "H3_1x1", "H4_1x1", "MP_1x1", "RP_1x1", "RS_1x1", "S2_1x1", "SC_1x1", "wild", "empty"];
    this.bigSymbolsL = ["L1_2x2", "L2_2x2", "L3_2x2", "L4_2x2", "L1_2x3", "L2_2x3", "L3_2x3", "L4_2x3"];
    this.bigSymbolsH = ["H1_2x2", "H2_2x2", "H3_2x2", "H4_2x2", "H1_2x3", "H2_2x3", "H3_2x3", "H4_2x3", "H1_3x3", "H2_3x3", "H3_3x3", "H4_3x3", "H1_3x4", "H2_3x4", "H3_3x4", "H4_3x4"];
    this.baseSymbolsID = ["L1", "L2", "L3", "L4", "H1", "H2", "H3", "H4", "MP", "RP", "RS", "S2", "SC", "wild", "empty"];
    this.bounceOffsetUp = 110;
    this.bounceOffsetDown = 0;
    this.stopDurationTime = 0.5;
    this.quickStopDurationTime = 1;
    this.reelGrid = "5x4";
  }
  setStopDurationTime(value) {
    this.stopDurationTime = value;
  }
  getStopDurationTime() {
    return this.stopDurationTime;
  }
  setBounceOffsetUp(value) {
    this.bounceOffsetUp = value;
  }
  getBounceOffsetUp() {
    return this.bounceOffsetUp;
  }
  setBounceOffsetDown(value) {
    this.bounceOffsetDown = value;
  }
  getBounceOffsetDown() {
    return this.bounceOffsetDown;
  }
  setBounceTimeNormal(value) {
    this.bounceTimeNormal = value;
  }
  getBounceTimeNormal() {
    return this.bounceTimeNormal;
  }
  setBounceTimeQuick(value) {
    this.bounceTimeQuick = value;
  }
  getBounceTimeQuick() {
    return this.bounceTimeQuick;
  }
  setReelsHolderStartX(value) {
    this.reelsHolderStartX = value;
  }
  getReelsHolderStartX() {
    return this.reelsHolderStartX;
  }
  setReelsHolderStartY(value) {
    this.reelsHolderStartY = value;
  }
  getReelsHolderStartY() {
    return this.reelsHolderStartY;
  }
  getSymbolWidth() {
    return this.symbolWidth;
  }
  setSymbolWidth(value) {
    this.symbolWidth = value;
  }
  getSymbolHeight() {
    return this.symbolHeight;
  }
  setSymbolHeight(value) {
    this.symbolHeight = value;
  }
  getNumOfReels() {
    return this.numReels;
  }
  setNumOfReels(value) {
    this.numReels = value;
  }
  getNumOfRows() {
    return this.numRows;
  }
  setNumOfRows(value) {
    this.numRows = value;
  }
  getReelsStartX() {
    return this.reelsStartX;
  }
  setReelsStartX(value) {
    this.reelsStartX = value;
  }
  getReelsStartY() {
    return this.reelsStartY;
  }
  setReelsStartY(value) {
    this.reelsStartY = value;
  }
  setSpinSpeed(value) {
    this.spinSpeed = value;
  }
  getSpinSpeed() {
    return this.spinSpeed;
  }
  setHasAnticipation(value) {
    this.hasAnticipation = value;
  }
  getAnticipation() {
    return this.hasAnticipation;
  }
  setAnticipationReels(reels) {
    this.anticipationReels = reels;
  }
  getAnticipationReels() {
    return this.anticipationReels;
  }
  setAnticipationTime(value) {
    this.anticipationTime = value;
  }
  getAnticipationTime() {
    return this.anticipationTime;
  }
  setSpinStopTime(value) {
    this.spinStopTime = value;
  }
  getSpinStopTime() {
    return this.spinStopTime;
  }
  setWildId(value) {
    this.wildID = value;
  }
  getWildId() {
    return this.wildID;
  }
  setScatterId(value) {
    this.scatterId = value;
  }
  getScatterId() {
    return this.scatterId;
  }
  setQucickSpinSpeed(value) {
    this.quickSpinSpeed = value;
  }
  getQucickSpinSpeed() {
    return this.quickSpinSpeed;
  }
  setSpringEnd(value) {
    this.springEnd = value;
  }
  getSpringEnd() {
    return this.springEnd;
  }
  getReelSymbolsIDs() {
    return this.reelSymbolsID;
  }
  setReelSymbolsIDs(data) {
    this.reelSymbolsID = data;
  }
  getBaseSymbolIds() {
    return this.baseSymbolsID;
  }
  getBigSymbolsL() {
    return this.bigSymbolsL;
  }
  getBigSymbolsH() {
    return this.bigSymbolsH;
  }
  getReelsStartDelayTime() {
    return this.reelsStartDelayTime;
  }
  setReelsStartDelayTime(value) {
    this.reelsStartDelayTime = value;
  }
  getQuickStopDurationTime() {
    return this.quickStopDurationTime;
  }
  setQuickStopDurationTime(value) {
    this.quickStopDurationTime = value;
  }
  getQuickStopSpinTime() {
    return this.quickStopSpinTime;
  }
  setTurboStopDurationTime(value) {
    this.turboStopSpinTime = value;
  }
  getTurboStopDurationTime() {
    return this.turboStopSpinTime;
  }
  getNormalReelStopDelay() {
    return this.normalReelStopDelay;
  }
  setNormalReelStopDelay(value) {
    this.normalReelStopDelay = value;
  }
  getQuickReelStopDelay() {
    return this.quickReelStopDelay;
  }
  setQuickReelStopDelay(value) {
    this.quickReelStopDelay = value;
  }
  setReelGrid(value) {
    this.reelGrid = value;
  }
  getReelGrid() {
    return this.reelGrid;
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/data/GameLoadData.js
var AssetsLibrary;
(function(AssetsLibrary_1) {
  AssetsLibrary_1.AssetsLibrary = {};
})(AssetsLibrary || (AssetsLibrary = {}));

// node_modules/my-pixi-coffee-pixi-game-framework/dist/data/Orientation.js
var Orientation = class {
};
Orientation.LANDSCAPE = "landscape";
Orientation.PORTRAIT = "portrait";

// node_modules/my-pixi-coffee-pixi-game-framework/dist/data/GameplayStates.js
var GameplayStates;
(function(GameplayStates2) {
  GameplayStates2[GameplayStates2["INTRO"] = 0] = "INTRO";
  GameplayStates2[GameplayStates2["MAIN_MENU"] = 1] = "MAIN_MENU";
  GameplayStates2[GameplayStates2["GAME"] = 2] = "GAME";
  GameplayStates2[GameplayStates2["END_GAME"] = 3] = "END_GAME";
})(GameplayStates || (GameplayStates = {}));

// node_modules/my-pixi-coffee-pixi-game-framework/dist/data/GameStates.js
var GameStates = class {
  constructor() {
    this.setInitialStates();
  }
  setOrientationState(state) {
    this.orientationState = state;
  }
  getOrientationState() {
    return this.orientationState;
  }
  setIsLandscapeState(value) {
    this.isLandscapeState = value;
  }
  getIsLandscapeState() {
    return this.isLandscapeState;
  }
  setIsMobile(value) {
    this.isMobile = value;
  }
  getIsMobile() {
    return this.isMobile;
  }
  setIsSoundOn(value) {
    this.isSoundOn = value;
  }
  getIsSoundOn() {
    return this.isSoundOn;
  }
  setIsGameSoundsOn(val) {
    this.isGameSoundsOn = val;
  }
  getIsGameSoundsOn() {
    return this.isGameSoundsOn;
  }
  setAmbientSound(value) {
    this.isAmbientSound = value;
  }
  getIsAmbientSound() {
    return this.isAmbientSound;
  }
  setIsGameEntered(value) {
    this.isGameEntered = value;
  }
  getIsGameEntered() {
    return this.isGameEntered;
  }
  setGameplayState(state) {
    this.gameplayState = state;
  }
  getGameplayState() {
    return this.gameplayState;
  }
  setInitialStates() {
    this.setIsLandscapeState(true);
    this.setIsMobile(false);
    this.setOrientationState(Orientation.LANDSCAPE);
    this.setIsSoundOn(true);
    this.setAmbientSound(true);
    this.setIsGameEntered(false);
    this.setGameplayState(GameplayStates.INTRO);
  }
};
GameStates.ENTER_GAME = "ENTER_GAME";

// node_modules/my-pixi-coffee-pixi-game-framework/dist/data/GameStatus.js
var GameStatus;
(function(GameStatus2) {
  GameStatus2["LOADING"] = "LOADING";
})(GameStatus || (GameStatus = {}));

// node_modules/@pixi/sound/lib/instance.mjs
var instance;
function setInstance(sound2) {
  instance = sound2;
  return sound2;
}
function getInstance() {
  return instance;
}

// node_modules/@pixi/sound/lib/filters/Filter.mjs
var Filter = class {
  /**
   * @param {AudioNode} destination - The audio node to use as the destination for the input AudioNode
   * @param {AudioNode} [source] - Optional output node, defaults to destination node. This is useful
   *        when creating filters which contains multiple AudioNode elements chained together.
   */
  constructor(destination, source) {
    this.init(destination, source);
  }
  /** Reinitialize */
  init(destination, source) {
    this.destination = destination;
    this.source = source || destination;
  }
  /**
   * Connect to the destination.
   * @param {AudioNode} destination - The destination node to connect the output to
   */
  connect(destination) {
    var _a;
    (_a = this.source) == null ? void 0 : _a.connect(destination);
  }
  /** Completely disconnect filter from destination and source nodes. */
  disconnect() {
    var _a;
    (_a = this.source) == null ? void 0 : _a.disconnect();
  }
  /** Destroy the filter and don't use after this. */
  destroy() {
    this.disconnect();
    this.destination = null;
    this.source = null;
  }
};

// node_modules/@pixi/sound/lib/webaudio/WebAudioUtils.mjs
var WebAudioUtils = class {
  /**
   * Dezippering is removed in the future Web Audio API, instead
   * we use the `setValueAtTime` method, however, this is not available
   * in all environments (e.g., Android webview), so we fallback to the `value` setter.
   * @param param - AudioNode parameter object
   * @param value - Value to set
   * @return The value set
   */
  static setParamValue(param, value) {
    if (param.setValueAtTime) {
      const context = getInstance().context;
      param.setValueAtTime(value, context.audioContext.currentTime);
    } else {
      param.value = value;
    }
    return value;
  }
};

// node_modules/@pixi/sound/lib/filters/EqualizerFilter.mjs
var _EqualizerFilter = class extends Filter {
  /**
   * @param f32 - Default gain for 32 Hz
   * @param f64 - Default gain for 64 Hz
   * @param f125 - Default gain for 125 Hz
   * @param f250 - Default gain for 250 Hz
   * @param f500 - Default gain for 500 Hz
   * @param f1k - Default gain for 1000 Hz
   * @param f2k - Default gain for 2000 Hz
   * @param f4k - Default gain for 4000 Hz
   * @param f8k - Default gain for 8000 Hz
   * @param f16k - Default gain for 16000 Hz
   */
  constructor(f32 = 0, f64 = 0, f125 = 0, f250 = 0, f500 = 0, f1k = 0, f2k = 0, f4k = 0, f8k = 0, f16k = 0) {
    let bands = [];
    const equalizerBands = [
      {
        f: _EqualizerFilter.F32,
        type: "lowshelf",
        gain: f32
      },
      {
        f: _EqualizerFilter.F64,
        type: "peaking",
        gain: f64
      },
      {
        f: _EqualizerFilter.F125,
        type: "peaking",
        gain: f125
      },
      {
        f: _EqualizerFilter.F250,
        type: "peaking",
        gain: f250
      },
      {
        f: _EqualizerFilter.F500,
        type: "peaking",
        gain: f500
      },
      {
        f: _EqualizerFilter.F1K,
        type: "peaking",
        gain: f1k
      },
      {
        f: _EqualizerFilter.F2K,
        type: "peaking",
        gain: f2k
      },
      {
        f: _EqualizerFilter.F4K,
        type: "peaking",
        gain: f4k
      },
      {
        f: _EqualizerFilter.F8K,
        type: "peaking",
        gain: f8k
      },
      {
        f: _EqualizerFilter.F16K,
        type: "highshelf",
        gain: f16k
      }
    ];
    if (!getInstance().useLegacy) {
      bands = equalizerBands.map((band) => {
        const node = getInstance().context.audioContext.createBiquadFilter();
        node.type = band.type;
        WebAudioUtils.setParamValue(node.Q, 1);
        node.frequency.value = band.f;
        WebAudioUtils.setParamValue(node.gain, band.gain);
        return node;
      });
    }
    super(bands[0], bands[bands.length - 1]);
    this.bands = bands;
    this.bandsMap = {};
    for (let i = 0; i < this.bands.length; i++) {
      const node = this.bands[i];
      if (i > 0) {
        this.bands[i - 1].connect(node);
      }
      this.bandsMap[node.frequency.value] = node;
    }
  }
  /**
   * Set gain on a specific frequency.
   * @param frequency - The frequency, see EqualizerFilter.F* for bands
   * @param gain - Recommended -40 to 40.
   */
  setGain(frequency, gain = 0) {
    if (!this.bandsMap[frequency]) {
      throw new Error(`No band found for frequency ${frequency}`);
    }
    WebAudioUtils.setParamValue(this.bandsMap[frequency].gain, gain);
  }
  /**
   * Get gain amount on a specific frequency.
   * @return The amount of gain set.
   */
  getGain(frequency) {
    if (!this.bandsMap[frequency]) {
      throw new Error(`No band found for frequency ${frequency}`);
    }
    return this.bandsMap[frequency].gain.value;
  }
  /**
   * Gain at 32 Hz frequencey.
   * @default 0
   */
  set f32(value) {
    this.setGain(_EqualizerFilter.F32, value);
  }
  get f32() {
    return this.getGain(_EqualizerFilter.F32);
  }
  /**
   * Gain at 64 Hz frequencey.
   * @default 0
   */
  set f64(value) {
    this.setGain(_EqualizerFilter.F64, value);
  }
  get f64() {
    return this.getGain(_EqualizerFilter.F64);
  }
  /**
   * Gain at 125 Hz frequencey.
   * @default 0
   */
  set f125(value) {
    this.setGain(_EqualizerFilter.F125, value);
  }
  get f125() {
    return this.getGain(_EqualizerFilter.F125);
  }
  /**
   * Gain at 250 Hz frequencey.
   * @default 0
   */
  set f250(value) {
    this.setGain(_EqualizerFilter.F250, value);
  }
  get f250() {
    return this.getGain(_EqualizerFilter.F250);
  }
  /**
   * Gain at 500 Hz frequencey.
   * @default 0
   */
  set f500(value) {
    this.setGain(_EqualizerFilter.F500, value);
  }
  get f500() {
    return this.getGain(_EqualizerFilter.F500);
  }
  /**
   * Gain at 1 KHz frequencey.
   * @default 0
   */
  set f1k(value) {
    this.setGain(_EqualizerFilter.F1K, value);
  }
  get f1k() {
    return this.getGain(_EqualizerFilter.F1K);
  }
  /**
   * Gain at 2 KHz frequencey.
   * @default 0
   */
  set f2k(value) {
    this.setGain(_EqualizerFilter.F2K, value);
  }
  get f2k() {
    return this.getGain(_EqualizerFilter.F2K);
  }
  /**
   * Gain at 4 KHz frequencey.
   * @default 0
   */
  set f4k(value) {
    this.setGain(_EqualizerFilter.F4K, value);
  }
  get f4k() {
    return this.getGain(_EqualizerFilter.F4K);
  }
  /**
   * Gain at 8 KHz frequencey.
   * @default 0
   */
  set f8k(value) {
    this.setGain(_EqualizerFilter.F8K, value);
  }
  get f8k() {
    return this.getGain(_EqualizerFilter.F8K);
  }
  /**
   * Gain at 16 KHz frequencey.
   * @default 0
   */
  set f16k(value) {
    this.setGain(_EqualizerFilter.F16K, value);
  }
  get f16k() {
    return this.getGain(_EqualizerFilter.F16K);
  }
  /** Reset all frequency bands to have gain of 0 */
  reset() {
    this.bands.forEach((band) => {
      WebAudioUtils.setParamValue(band.gain, 0);
    });
  }
  destroy() {
    this.bands.forEach((band) => {
      band.disconnect();
    });
    this.bands = null;
    this.bandsMap = null;
  }
};
var EqualizerFilter = _EqualizerFilter;
EqualizerFilter.F32 = 32;
EqualizerFilter.F64 = 64;
EqualizerFilter.F125 = 125;
EqualizerFilter.F250 = 250;
EqualizerFilter.F500 = 500;
EqualizerFilter.F1K = 1e3;
EqualizerFilter.F2K = 2e3;
EqualizerFilter.F4K = 4e3;
EqualizerFilter.F8K = 8e3;
EqualizerFilter.F16K = 16e3;

// node_modules/@pixi/sound/lib/htmlaudio/HTMLAudioContext.mjs
var HTMLAudioContext = class extends eventemitter3_default {
  constructor() {
    super(...arguments);
    this.speed = 1;
    this.muted = false;
    this.volume = 1;
    this.paused = false;
  }
  /** Internal trigger when volume, mute or speed changes */
  refresh() {
    this.emit("refresh");
  }
  /** Internal trigger paused changes */
  refreshPaused() {
    this.emit("refreshPaused");
  }
  /**
   * HTML Audio does not support filters, this is non-functional API.
   */
  get filters() {
    console.warn("HTML Audio does not support filters");
    return null;
  }
  set filters(_filters) {
    console.warn("HTML Audio does not support filters");
  }
  /**
   * HTML Audio does not support `audioContext`
   * @readonly
   * @type {AudioContext}
   */
  get audioContext() {
    console.warn("HTML Audio does not support audioContext");
    return null;
  }
  /**
   * Toggles the muted state.
   * @return The current muted state.
   */
  toggleMute() {
    this.muted = !this.muted;
    this.refresh();
    return this.muted;
  }
  /**
   * Toggles the paused state.
   * @return The current paused state.
   */
  togglePause() {
    this.paused = !this.paused;
    this.refreshPaused();
    return this.paused;
  }
  /** Destroy and don't use after this */
  destroy() {
    this.removeAllListeners();
  }
};

// node_modules/@pixi/sound/lib/htmlaudio/HTMLAudioInstance.mjs
var id = 0;
var _HTMLAudioInstance = class extends eventemitter3_default {
  /** @param parent - Parent element */
  constructor(parent) {
    super();
    this.id = id++;
    this.init(parent);
  }
  /**
   * Set a property by name, this makes it easy to chain values
   * @param name - Name of the property to set
   * @param value - Value to set property to
   */
  set(name, value) {
    if (this[name] === void 0) {
      throw new Error(`Property with name ${name} does not exist.`);
    } else {
      switch (name) {
        case "speed":
          this.speed = value;
          break;
        case "volume":
          this.volume = value;
          break;
        case "paused":
          this.paused = value;
          break;
        case "loop":
          this.loop = value;
          break;
        case "muted":
          this.muted = value;
          break;
      }
    }
    return this;
  }
  /** The current playback progress from 0 to 1. */
  get progress() {
    const { currentTime } = this._source;
    return currentTime / this._duration;
  }
  /** Pauses the sound. */
  get paused() {
    return this._paused;
  }
  set paused(paused) {
    this._paused = paused;
    this.refreshPaused();
  }
  /**
   * Reference: http://stackoverflow.com/a/40370077
   * @private
   */
  _onPlay() {
    this._playing = true;
  }
  /**
   * Reference: http://stackoverflow.com/a/40370077
   * @private
   */
  _onPause() {
    this._playing = false;
  }
  /**
   * Initialize the instance.
   * @param {htmlaudio.HTMLAudioMedia} media - Same as constructor
   */
  init(media) {
    this._playing = false;
    this._duration = media.source.duration;
    const source = this._source = media.source.cloneNode(false);
    source.src = media.parent.url;
    source.onplay = this._onPlay.bind(this);
    source.onpause = this._onPause.bind(this);
    media.context.on("refresh", this.refresh, this);
    media.context.on("refreshPaused", this.refreshPaused, this);
    this._media = media;
  }
  /**
   * Stop the sound playing
   * @private
   */
  _internalStop() {
    if (this._source && this._playing) {
      this._source.onended = null;
      this._source.pause();
    }
  }
  /** Stop the sound playing */
  stop() {
    this._internalStop();
    if (this._source) {
      this.emit("stop");
    }
  }
  /** Set the instance speed from 0 to 1 */
  get speed() {
    return this._speed;
  }
  set speed(speed) {
    this._speed = speed;
    this.refresh();
  }
  /** Get the set the volume for this instance from 0 to 1 */
  get volume() {
    return this._volume;
  }
  set volume(volume) {
    this._volume = volume;
    this.refresh();
  }
  /** If the sound instance should loop playback */
  get loop() {
    return this._loop;
  }
  set loop(loop) {
    this._loop = loop;
    this.refresh();
  }
  /** `true` if the sound is muted */
  get muted() {
    return this._muted;
  }
  set muted(muted) {
    this._muted = muted;
    this.refresh();
  }
  /**
   * HTML Audio does not support filters, this is non-functional API.
   */
  get filters() {
    console.warn("HTML Audio does not support filters");
    return null;
  }
  set filters(_filters) {
    console.warn("HTML Audio does not support filters");
  }
  /** Call whenever the loop, speed or volume changes */
  refresh() {
    const global2 = this._media.context;
    const sound2 = this._media.parent;
    this._source.loop = this._loop || sound2.loop;
    const globalVolume = global2.volume * (global2.muted ? 0 : 1);
    const soundVolume = sound2.volume * (sound2.muted ? 0 : 1);
    const instanceVolume = this._volume * (this._muted ? 0 : 1);
    this._source.volume = instanceVolume * globalVolume * soundVolume;
    this._source.playbackRate = this._speed * global2.speed * sound2.speed;
  }
  /** Handle changes in paused state, either globally or sound or instance */
  refreshPaused() {
    const global2 = this._media.context;
    const sound2 = this._media.parent;
    const pausedReal = this._paused || sound2.paused || global2.paused;
    if (pausedReal !== this._pausedReal) {
      this._pausedReal = pausedReal;
      if (pausedReal) {
        this._internalStop();
        this.emit("paused");
      } else {
        this.emit("resumed");
        this.play({
          start: this._source.currentTime,
          end: this._end,
          volume: this._volume,
          speed: this._speed,
          loop: this._loop
        });
      }
      this.emit("pause", pausedReal);
    }
  }
  /** Start playing the sound/ */
  play(options) {
    const { start, end, speed, loop, volume, muted } = options;
    if (end) {
      console.assert(end > start, "End time is before start time");
    }
    this._speed = speed;
    this._volume = volume;
    this._loop = !!loop;
    this._muted = muted;
    this.refresh();
    if (this.loop && end !== null) {
      console.warn('Looping not support when specifying an "end" time');
      this.loop = false;
    }
    this._start = start;
    this._end = end || this._duration;
    this._start = Math.max(0, this._start - _HTMLAudioInstance.PADDING);
    this._end = Math.min(this._end + _HTMLAudioInstance.PADDING, this._duration);
    this._source.onloadedmetadata = () => {
      if (this._source) {
        this._source.currentTime = start;
        this._source.onloadedmetadata = null;
        this.emit("progress", start / this._duration, this._duration);
        Ticker.shared.add(this._onUpdate, this);
      }
    };
    this._source.onended = this._onComplete.bind(this);
    this._source.play();
    this.emit("start");
  }
  /**
   * Handle time update on sound.
   * @private
   */
  _onUpdate() {
    this.emit("progress", this.progress, this._duration);
    if (this._source.currentTime >= this._end && !this._source.loop) {
      this._onComplete();
    }
  }
  /**
   * Callback when completed.
   * @private
   */
  _onComplete() {
    Ticker.shared.remove(this._onUpdate, this);
    this._internalStop();
    this.emit("progress", 1, this._duration);
    this.emit("end", this);
  }
  /** Don't use after this. */
  destroy() {
    Ticker.shared.remove(this._onUpdate, this);
    this.removeAllListeners();
    const source = this._source;
    if (source) {
      source.onended = null;
      source.onplay = null;
      source.onpause = null;
      this._internalStop();
    }
    this._source = null;
    this._speed = 1;
    this._volume = 1;
    this._loop = false;
    this._end = null;
    this._start = 0;
    this._duration = 0;
    this._playing = false;
    this._pausedReal = false;
    this._paused = false;
    this._muted = false;
    if (this._media) {
      this._media.context.off("refresh", this.refresh, this);
      this._media.context.off("refreshPaused", this.refreshPaused, this);
      this._media = null;
    }
  }
  /**
   * To string method for instance.
   * @return The string representation of instance.
   */
  toString() {
    return `[HTMLAudioInstance id=${this.id}]`;
  }
};
var HTMLAudioInstance = _HTMLAudioInstance;
HTMLAudioInstance.PADDING = 0.1;

// node_modules/@pixi/sound/lib/htmlaudio/HTMLAudioMedia.mjs
var HTMLAudioMedia = class extends eventemitter3_default {
  init(parent) {
    this.parent = parent;
    this._source = parent.options.source || new Audio();
    if (parent.url) {
      this._source.src = parent.url;
    }
  }
  // Implement create
  create() {
    return new HTMLAudioInstance(this);
  }
  /**
   * If the audio media is playable (ready).
   * @readonly
   */
  get isPlayable() {
    return !!this._source && this._source.readyState === 4;
  }
  /**
   * THe duration of the media in seconds.
   * @readonly
   */
  get duration() {
    return this._source.duration;
  }
  /**
   * Reference to the context.
   * @readonly
   */
  get context() {
    return this.parent.context;
  }
  /** The collection of filters, does not apply to HTML Audio. */
  get filters() {
    return null;
  }
  set filters(_filters) {
    console.warn("HTML Audio does not support filters");
  }
  // Override the destroy
  destroy() {
    this.removeAllListeners();
    this.parent = null;
    if (this._source) {
      this._source.src = "";
      this._source.load();
      this._source = null;
    }
  }
  /**
   * Get the audio source element.
   * @type {HTMLAudioElement}
   * @readonly
   */
  get source() {
    return this._source;
  }
  // Implement the method to being preloading
  load(callback) {
    const source = this._source;
    const sound2 = this.parent;
    if (source.readyState === 4) {
      sound2.isLoaded = true;
      const instance2 = sound2.autoPlayStart();
      if (callback) {
        setTimeout(() => {
          callback(null, sound2, instance2);
        }, 0);
      }
      return;
    }
    if (!sound2.url) {
      callback(new Error("sound.url or sound.source must be set"));
      return;
    }
    source.src = sound2.url;
    const onLoad = () => {
      removeListeners();
      sound2.isLoaded = true;
      const instance2 = sound2.autoPlayStart();
      if (callback) {
        callback(null, sound2, instance2);
      }
    };
    const onAbort = () => {
      removeListeners();
      if (callback) {
        callback(new Error("Sound loading has been aborted"));
      }
    };
    const onError = () => {
      removeListeners();
      const message = `Failed to load audio element (code: ${source.error.code})`;
      if (callback) {
        callback(new Error(message));
      } else {
        console.error(message);
      }
    };
    const removeListeners = () => {
      source.removeEventListener("canplaythrough", onLoad);
      source.removeEventListener("load", onLoad);
      source.removeEventListener("abort", onAbort);
      source.removeEventListener("error", onError);
    };
    source.addEventListener("canplaythrough", onLoad, false);
    source.addEventListener("load", onLoad, false);
    source.addEventListener("abort", onAbort, false);
    source.addEventListener("error", onError, false);
    source.load();
  }
};

// node_modules/@pixi/sound/lib/SoundSprite.mjs
var SoundSprite = class {
  /**
   * @param parent - The parent sound
   * @param options - Data associated with object.
   */
  constructor(parent, options) {
    this.parent = parent;
    Object.assign(this, options);
    this.duration = this.end - this.start;
    console.assert(this.duration > 0, "End time must be after start time");
  }
  /**
   * Play the sound sprite.
   * @param {Function} [complete] - Function call when complete
   * @return Sound instance being played.
   */
  play(complete) {
    return this.parent.play({
      complete,
      speed: this.speed || this.parent.speed,
      end: this.end,
      start: this.start,
      loop: this.loop
    });
  }
  /** Destroy and don't use after this */
  destroy() {
    this.parent = null;
  }
};

// node_modules/@pixi/sound/lib/utils/supported.mjs
var extensions2 = [
  "ogg",
  "oga",
  "opus",
  "m4a",
  "mp3",
  "mpeg",
  "wav",
  "aiff",
  "wma",
  "mid",
  "caf"
];
var mimes = [
  "audio/mpeg",
  "audio/ogg"
];
var supported = {};
function validateFormats(typeOverrides) {
  const overrides = {
    m4a: "audio/mp4",
    oga: "audio/ogg",
    opus: 'audio/ogg; codecs="opus"',
    caf: 'audio/x-caf; codecs="opus"',
    ...typeOverrides || {}
  };
  const audio = document.createElement("audio");
  const formats = {};
  const no = /^no$/;
  extensions2.forEach((ext) => {
    const canByExt = audio.canPlayType(`audio/${ext}`).replace(no, "");
    const canByType = overrides[ext] ? audio.canPlayType(overrides[ext]).replace(no, "") : "";
    formats[ext] = !!canByExt || !!canByType;
  });
  Object.assign(supported, formats);
}
validateFormats();

// node_modules/@pixi/sound/lib/webaudio/WebAudioInstance.mjs
var id2 = 0;
var WebAudioInstance = class extends eventemitter3_default {
  constructor(media) {
    super();
    this.id = id2++;
    this._media = null;
    this._paused = false;
    this._muted = false;
    this._elapsed = 0;
    this.init(media);
  }
  /**
   * Set a property by name, this makes it easy to chain values
   * @param name - Name of the property to set.
   * @param value - Value to set property to.
   */
  set(name, value) {
    if (this[name] === void 0) {
      throw new Error(`Property with name ${name} does not exist.`);
    } else {
      switch (name) {
        case "speed":
          this.speed = value;
          break;
        case "volume":
          this.volume = value;
          break;
        case "muted":
          this.muted = value;
          break;
        case "loop":
          this.loop = value;
          break;
        case "paused":
          this.paused = value;
          break;
      }
    }
    return this;
  }
  /** Stops the instance, don't use after this. */
  stop() {
    if (this._source) {
      this._internalStop();
      this.emit("stop");
    }
  }
  /** Set the instance speed from 0 to 1 */
  get speed() {
    return this._speed;
  }
  set speed(speed) {
    this._speed = speed;
    this.refresh();
    this._update(true);
  }
  /** Get the set the volume for this instance from 0 to 1 */
  get volume() {
    return this._volume;
  }
  set volume(volume) {
    this._volume = volume;
    this.refresh();
  }
  /** `true` if the sound is muted */
  get muted() {
    return this._muted;
  }
  set muted(muted) {
    this._muted = muted;
    this.refresh();
  }
  /** If the sound instance should loop playback */
  get loop() {
    return this._loop;
  }
  set loop(loop) {
    this._loop = loop;
    this.refresh();
  }
  /** The collection of filters. */
  get filters() {
    return this._filters;
  }
  set filters(filters) {
    var _a;
    if (this._filters) {
      (_a = this._filters) == null ? void 0 : _a.filter((filter) => filter).forEach((filter) => filter.disconnect());
      this._filters = null;
      this._source.connect(this._gain);
    }
    this._filters = (filters == null ? void 0 : filters.length) ? filters.slice(0) : null;
    this.refresh();
  }
  /** Refresh loop, volume and speed based on changes to parent */
  refresh() {
    if (!this._source) {
      return;
    }
    const global2 = this._media.context;
    const sound2 = this._media.parent;
    this._source.loop = this._loop || sound2.loop;
    const globalVolume = global2.volume * (global2.muted ? 0 : 1);
    const soundVolume = sound2.volume * (sound2.muted ? 0 : 1);
    const instanceVolume = this._volume * (this._muted ? 0 : 1);
    WebAudioUtils.setParamValue(this._gain.gain, instanceVolume * soundVolume * globalVolume);
    WebAudioUtils.setParamValue(this._source.playbackRate, this._speed * sound2.speed * global2.speed);
    this.applyFilters();
  }
  /** Connect filters nodes to audio context */
  applyFilters() {
    var _a;
    if ((_a = this._filters) == null ? void 0 : _a.length) {
      this._source.disconnect();
      let source = this._source;
      this._filters.forEach((filter) => {
        source.connect(filter.destination);
        source = filter;
      });
      source.connect(this._gain);
    }
  }
  /** Handle changes in paused state, either globally or sound or instance */
  refreshPaused() {
    const global2 = this._media.context;
    const sound2 = this._media.parent;
    const pausedReal = this._paused || sound2.paused || global2.paused;
    if (pausedReal !== this._pausedReal) {
      this._pausedReal = pausedReal;
      if (pausedReal) {
        this._internalStop();
        this.emit("paused");
      } else {
        this.emit("resumed");
        this.play({
          start: this._elapsed % this._duration,
          end: this._end,
          speed: this._speed,
          loop: this._loop,
          volume: this._volume
        });
      }
      this.emit("pause", pausedReal);
    }
  }
  /**
   * Plays the sound.
   * @param options - Play options.
   */
  play(options) {
    const { start, end, speed, loop, volume, muted, filters } = options;
    if (end) {
      console.assert(end > start, "End time is before start time");
    }
    this._paused = false;
    const { source, gain } = this._media.nodes.cloneBufferSource();
    this._source = source;
    this._gain = gain;
    this._speed = speed;
    this._volume = volume;
    this._loop = !!loop;
    this._muted = muted;
    this._filters = filters;
    this.refresh();
    const duration = this._source.buffer.duration;
    this._duration = duration;
    this._end = end;
    this._lastUpdate = this._now();
    this._elapsed = start;
    this._source.onended = this._onComplete.bind(this);
    if (this._loop) {
      this._source.loopEnd = end;
      this._source.loopStart = start;
      this._source.start(0, start);
    } else if (end) {
      this._source.start(0, start, end - start);
    } else {
      this._source.start(0, start);
    }
    this.emit("start");
    this._update(true);
    this.enableTicker(true);
  }
  /** Start the update progress. */
  enableTicker(enabled) {
    Ticker.shared.remove(this._updateListener, this);
    if (enabled) {
      Ticker.shared.add(this._updateListener, this);
    }
  }
  /** The current playback progress from 0 to 1. */
  get progress() {
    return this._progress;
  }
  /** Pauses the sound. */
  get paused() {
    return this._paused;
  }
  set paused(paused) {
    this._paused = paused;
    this.refreshPaused();
  }
  /** Don't use after this. */
  destroy() {
    var _a;
    this.removeAllListeners();
    this._internalStop();
    if (this._gain) {
      this._gain.disconnect();
      this._gain = null;
    }
    if (this._media) {
      this._media.context.events.off("refresh", this.refresh, this);
      this._media.context.events.off("refreshPaused", this.refreshPaused, this);
      this._media = null;
    }
    (_a = this._filters) == null ? void 0 : _a.forEach((filter) => filter.disconnect());
    this._filters = null;
    this._end = null;
    this._speed = 1;
    this._volume = 1;
    this._loop = false;
    this._elapsed = 0;
    this._duration = 0;
    this._paused = false;
    this._muted = false;
    this._pausedReal = false;
  }
  /**
   * To string method for instance.
   * @return The string representation of instance.
   */
  toString() {
    return `[WebAudioInstance id=${this.id}]`;
  }
  /**
   * Get the current time in seconds.
   * @return Seconds since start of context
   */
  _now() {
    return this._media.context.audioContext.currentTime;
  }
  /** Callback for update listener */
  _updateListener() {
    this._update();
  }
  /** Internal update the progress. */
  _update(force = false) {
    if (this._source) {
      const now = this._now();
      const delta = now - this._lastUpdate;
      if (delta > 0 || force) {
        const speed = this._source.playbackRate.value;
        this._elapsed += delta * speed;
        this._lastUpdate = now;
        const duration = this._duration;
        let progress;
        if (this._source.loopStart) {
          const soundLength = this._source.loopEnd - this._source.loopStart;
          progress = (this._source.loopStart + this._elapsed % soundLength) / duration;
        } else {
          progress = this._elapsed % duration / duration;
        }
        this._progress = progress;
        this.emit("progress", this._progress, duration);
      }
    }
  }
  /** Initializes the instance. */
  init(media) {
    this._media = media;
    media.context.events.on("refresh", this.refresh, this);
    media.context.events.on("refreshPaused", this.refreshPaused, this);
  }
  /** Stops the instance. */
  _internalStop() {
    if (this._source) {
      this.enableTicker(false);
      this._source.onended = null;
      this._source.stop(0);
      this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch (err) {
        console.warn("Failed to set AudioBufferSourceNode.buffer to null:", err);
      }
      this._source = null;
    }
  }
  /** Callback when completed. */
  _onComplete() {
    if (this._source) {
      this.enableTicker(false);
      this._source.onended = null;
      this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch (err) {
        console.warn("Failed to set AudioBufferSourceNode.buffer to null:", err);
      }
    }
    this._source = null;
    this._progress = 1;
    this.emit("progress", 1, this._duration);
    this.emit("end", this);
  }
};

// node_modules/@pixi/sound/lib/Filterable.mjs
var Filterable = class {
  /**
   * @param input - The source audio node
   * @param output - The output audio node
   */
  constructor(input, output) {
    this._output = output;
    this._input = input;
  }
  /** The destination output audio node */
  get destination() {
    return this._input;
  }
  /** The collection of filters. */
  get filters() {
    return this._filters;
  }
  set filters(filters) {
    if (this._filters) {
      this._filters.forEach((filter) => {
        if (filter) {
          filter.disconnect();
        }
      });
      this._filters = null;
      this._input.connect(this._output);
    }
    if (filters && filters.length) {
      this._filters = filters.slice(0);
      this._input.disconnect();
      let prevFilter = null;
      filters.forEach((filter) => {
        if (prevFilter === null) {
          this._input.connect(filter.destination);
        } else {
          prevFilter.connect(filter.destination);
        }
        prevFilter = filter;
      });
      prevFilter.connect(this._output);
    }
  }
  /** Cleans up. */
  destroy() {
    this.filters = null;
    this._input = null;
    this._output = null;
  }
};

// node_modules/@pixi/sound/lib/webaudio/WebAudioNodes.mjs
var _WebAudioNodes = class extends Filterable {
  /**
   * @param context - The audio context.
   */
  constructor(context) {
    const audioContext = context.audioContext;
    const bufferSource = audioContext.createBufferSource();
    const gain = audioContext.createGain();
    const analyser = audioContext.createAnalyser();
    bufferSource.connect(analyser);
    analyser.connect(gain);
    gain.connect(context.destination);
    super(analyser, gain);
    this.context = context;
    this.bufferSource = bufferSource;
    this.gain = gain;
    this.analyser = analyser;
  }
  /**
   * Get the script processor node.
   * @readonly
   */
  get script() {
    if (!this._script) {
      this._script = this.context.audioContext.createScriptProcessor(_WebAudioNodes.BUFFER_SIZE);
      this._script.connect(this.context.destination);
    }
    return this._script;
  }
  /** Cleans up. */
  destroy() {
    super.destroy();
    this.bufferSource.disconnect();
    if (this._script) {
      this._script.disconnect();
    }
    this.gain.disconnect();
    this.analyser.disconnect();
    this.bufferSource = null;
    this._script = null;
    this.gain = null;
    this.analyser = null;
    this.context = null;
  }
  /**
   * Clones the bufferSource. Used just before playing a sound.
   * @returns {SourceClone} The clone AudioBufferSourceNode.
   */
  cloneBufferSource() {
    const orig = this.bufferSource;
    const source = this.context.audioContext.createBufferSource();
    source.buffer = orig.buffer;
    WebAudioUtils.setParamValue(source.playbackRate, orig.playbackRate.value);
    source.loop = orig.loop;
    const gain = this.context.audioContext.createGain();
    source.connect(gain);
    gain.connect(this.destination);
    return { source, gain };
  }
  /**
   * Get buffer size of `ScriptProcessorNode`.
   * @readonly
   */
  get bufferSize() {
    return this.script.bufferSize;
  }
};
var WebAudioNodes = _WebAudioNodes;
WebAudioNodes.BUFFER_SIZE = 0;

// node_modules/@pixi/sound/lib/webaudio/WebAudioMedia.mjs
var WebAudioMedia = class {
  /**
   * Re-initialize without constructing.
   * @param parent - - Instance of parent Sound container
   */
  init(parent) {
    this.parent = parent;
    this._nodes = new WebAudioNodes(this.context);
    this._source = this._nodes.bufferSource;
    this.source = parent.options.source;
  }
  /** Destructor, safer to use `SoundLibrary.remove(alias)` to remove this sound. */
  destroy() {
    this.parent = null;
    this._nodes.destroy();
    this._nodes = null;
    try {
      this._source.buffer = null;
    } catch (err) {
      console.warn("Failed to set AudioBufferSourceNode.buffer to null:", err);
    }
    this._source = null;
    this.source = null;
  }
  // Implement create
  create() {
    return new WebAudioInstance(this);
  }
  // Implement context
  get context() {
    return this.parent.context;
  }
  // Implement isPlayable
  get isPlayable() {
    return !!this._source && !!this._source.buffer;
  }
  // Implement filters
  get filters() {
    return this._nodes.filters;
  }
  set filters(filters) {
    this._nodes.filters = filters;
  }
  // Implements duration
  get duration() {
    console.assert(this.isPlayable, "Sound not yet playable, no duration");
    return this._source.buffer.duration;
  }
  /** Gets and sets the buffer. */
  get buffer() {
    return this._source.buffer;
  }
  set buffer(buffer) {
    this._source.buffer = buffer;
  }
  /** Get the current chained nodes object */
  get nodes() {
    return this._nodes;
  }
  // Implements load
  load(callback) {
    if (this.source) {
      this._decode(this.source, callback);
    } else if (this.parent.url) {
      this._loadUrl(callback);
    } else if (callback) {
      callback(new Error("sound.url or sound.source must be set"));
    } else {
      console.error("sound.url or sound.source must be set");
    }
  }
  /** Loads a sound using XHMLHttpRequest object. */
  async _loadUrl(callback) {
    const url = this.parent.url;
    const response = await DOMAdapter.get().fetch(url);
    this._decode(await response.arrayBuffer(), callback);
  }
  /**
   * Decodes the array buffer.
   * @param arrayBuffer - From load.
   * @param {Function} callback - Callback optional
   */
  _decode(arrayBuffer, callback) {
    const audioBufferReadyFn = (err, buffer) => {
      if (err) {
        if (callback) {
          callback(err);
        }
      } else {
        this.parent.isLoaded = true;
        this.buffer = buffer;
        const instance2 = this.parent.autoPlayStart();
        if (callback) {
          callback(null, this.parent, instance2);
        }
      }
    };
    if (arrayBuffer instanceof AudioBuffer) {
      audioBufferReadyFn(null, arrayBuffer);
    } else {
      const context = this.parent.context;
      context.decode(arrayBuffer, audioBufferReadyFn);
    }
  }
};

// node_modules/@pixi/sound/lib/Sound.mjs
var _Sound = class {
  /**
   * Create a new sound instance from source.
   * @param source - Either the path or url to the source file.
   *        or the object of options to use.
   * @return Created sound instance.
   */
  static from(source) {
    let options = {};
    if (typeof source === "string") {
      options.url = source;
    } else if (source instanceof ArrayBuffer || source instanceof AudioBuffer || source instanceof HTMLAudioElement) {
      options.source = source;
    } else if (Array.isArray(source)) {
      options.url = source;
    } else {
      options = source;
    }
    options = {
      autoPlay: false,
      singleInstance: false,
      url: null,
      source: null,
      preload: false,
      volume: 1,
      speed: 1,
      complete: null,
      loaded: null,
      loop: false,
      ...options
    };
    Object.freeze(options);
    const media = getInstance().useLegacy ? new HTMLAudioMedia() : new WebAudioMedia();
    return new _Sound(media, options);
  }
  /**
   * Use `Sound.from`
   * @ignore
   */
  constructor(media, options) {
    this.media = media;
    this.options = options;
    this._instances = [];
    this._sprites = {};
    this.media.init(this);
    const complete = options.complete;
    this._autoPlayOptions = complete ? { complete } : null;
    this.isLoaded = false;
    this._preloadQueue = null;
    this.isPlaying = false;
    this.autoPlay = options.autoPlay;
    this.singleInstance = options.singleInstance;
    this.preload = options.preload || this.autoPlay;
    this.url = Array.isArray(options.url) ? this.preferUrl(options.url) : options.url;
    this.speed = options.speed;
    this.volume = options.volume;
    this.loop = options.loop;
    if (options.sprites) {
      this.addSprites(options.sprites);
    }
    if (this.preload) {
      this._preload(options.loaded);
    }
  }
  /**
   * Internal help for resolving which file to use if there are multiple provide
   * this is especially helpful for working with bundlers (non Assets loading).
   */
  preferUrl(urls) {
    const [file] = urls.map((url) => ({ url, ext: path.extname(url).slice(1) })).filter(({ ext }) => supported[ext]).sort((a, b) => extensions2.indexOf(a.ext) - extensions2.indexOf(b.ext));
    if (!file) {
      throw new Error("No supported file type found");
    }
    return file.url;
  }
  /** Instance of the media context. */
  get context() {
    return getInstance().context;
  }
  /** Stops all the instances of this sound from playing. */
  pause() {
    this.isPlaying = false;
    this.paused = true;
    return this;
  }
  /** Resuming all the instances of this sound from playing */
  resume() {
    this.isPlaying = this._instances.length > 0;
    this.paused = false;
    return this;
  }
  /** Stops all the instances of this sound from playing. */
  get paused() {
    return this._paused;
  }
  set paused(paused) {
    this._paused = paused;
    this.refreshPaused();
  }
  /** The playback rate. */
  get speed() {
    return this._speed;
  }
  set speed(speed) {
    this._speed = speed;
    this.refresh();
  }
  /** Set the filters. Only supported with WebAudio. */
  get filters() {
    return this.media.filters;
  }
  set filters(filters) {
    this.media.filters = filters;
  }
  /**
   * @ignore
   */
  addSprites(source, data) {
    if (typeof source === "object") {
      const results = {};
      for (const alias in source) {
        results[alias] = this.addSprites(alias, source[alias]);
      }
      return results;
    }
    console.assert(!this._sprites[source], `Alias ${source} is already taken`);
    const sprite = new SoundSprite(this, data);
    this._sprites[source] = sprite;
    return sprite;
  }
  /** Destructor, safer to use `SoundLibrary.remove(alias)` to remove this sound. */
  destroy() {
    this._removeInstances();
    this.removeSprites();
    this.media.destroy();
    this.media = null;
    this._sprites = null;
    this._instances = null;
  }
  /**
   * Remove a sound sprite.
   * @param alias - The unique name of the sound sprite, if alias is omitted, removes all sprites.
   */
  removeSprites(alias) {
    if (!alias) {
      for (const name in this._sprites) {
        this.removeSprites(name);
      }
    } else {
      const sprite = this._sprites[alias];
      if (sprite !== void 0) {
        sprite.destroy();
        delete this._sprites[alias];
      }
    }
    return this;
  }
  /** If the current sound is playable (loaded). */
  get isPlayable() {
    return this.isLoaded && this.media && this.media.isPlayable;
  }
  /** Stops all the instances of this sound from playing. */
  stop() {
    if (!this.isPlayable) {
      this.autoPlay = false;
      this._autoPlayOptions = null;
      return this;
    }
    this.isPlaying = false;
    for (let i = this._instances.length - 1; i >= 0; i--) {
      this._instances[i].stop();
    }
    return this;
  }
  // Overloaded function
  play(source, complete) {
    let options;
    if (typeof source === "string") {
      const sprite = source;
      options = { sprite, loop: this.loop, complete };
    } else if (typeof source === "function") {
      options = {};
      options.complete = source;
    } else {
      options = source;
    }
    options = {
      complete: null,
      loaded: null,
      sprite: null,
      end: null,
      start: 0,
      volume: 1,
      speed: 1,
      muted: false,
      loop: false,
      ...options || {}
    };
    if (options.sprite) {
      const alias = options.sprite;
      console.assert(!!this._sprites[alias], `Alias ${alias} is not available`);
      const sprite = this._sprites[alias];
      options.start = sprite.start + (options.start || 0);
      options.end = sprite.end;
      options.speed = sprite.speed || 1;
      options.loop = sprite.loop || options.loop;
      delete options.sprite;
    }
    if (options.offset) {
      options.start = options.offset;
    }
    if (!this.isLoaded) {
      if (this._preloadQueue) {
        return new Promise((resolve) => {
          this._preloadQueue.push(() => {
            resolve(this.play(options));
          });
        });
      }
      this._preloadQueue = [];
      this.autoPlay = true;
      this._autoPlayOptions = options;
      return new Promise((resolve, reject) => {
        this._preload((err, sound2, media) => {
          this._preloadQueue.forEach((resolve2) => resolve2());
          this._preloadQueue = null;
          if (err) {
            reject(err);
          } else {
            if (options.loaded) {
              options.loaded(err, sound2, media);
            }
            resolve(media);
          }
        });
      });
    }
    if (this.singleInstance || options.singleInstance) {
      this._removeInstances();
    }
    const instance2 = this._createInstance();
    this._instances.push(instance2);
    this.isPlaying = true;
    instance2.once("end", () => {
      if (options.complete) {
        options.complete(this);
      }
      this._onComplete(instance2);
    });
    instance2.once("stop", () => {
      this._onComplete(instance2);
    });
    instance2.play(options);
    return instance2;
  }
  /** Internal only, speed, loop, volume change occured. */
  refresh() {
    const len = this._instances.length;
    for (let i = 0; i < len; i++) {
      this._instances[i].refresh();
    }
  }
  /** Handle changes in paused state. Internal only. */
  refreshPaused() {
    const len = this._instances.length;
    for (let i = 0; i < len; i++) {
      this._instances[i].refreshPaused();
    }
  }
  /** Gets and sets the volume. */
  get volume() {
    return this._volume;
  }
  set volume(volume) {
    this._volume = volume;
    this.refresh();
  }
  /** Gets and sets the muted flag. */
  get muted() {
    return this._muted;
  }
  set muted(muted) {
    this._muted = muted;
    this.refresh();
  }
  /** Gets and sets the looping. */
  get loop() {
    return this._loop;
  }
  set loop(loop) {
    this._loop = loop;
    this.refresh();
  }
  /** Starts the preloading of sound. */
  _preload(callback) {
    this.media.load(callback);
  }
  /** Gets the list of instances that are currently being played of this sound. */
  get instances() {
    return this._instances;
  }
  /** Get the map of sprites. */
  get sprites() {
    return this._sprites;
  }
  /** Get the duration of the audio in seconds. */
  get duration() {
    return this.media.duration;
  }
  /** Auto play the first instance. */
  autoPlayStart() {
    let instance2;
    if (this.autoPlay) {
      instance2 = this.play(this._autoPlayOptions);
    }
    return instance2;
  }
  /** Removes all instances. */
  _removeInstances() {
    for (let i = this._instances.length - 1; i >= 0; i--) {
      this._poolInstance(this._instances[i]);
    }
    this._instances.length = 0;
  }
  /**
   * Sound instance completed.
   * @param instance
   */
  _onComplete(instance2) {
    if (this._instances) {
      const index = this._instances.indexOf(instance2);
      if (index > -1) {
        this._instances.splice(index, 1);
      }
      this.isPlaying = this._instances.length > 0;
    }
    this._poolInstance(instance2);
  }
  /** Create a new instance. */
  _createInstance() {
    if (_Sound._pool.length > 0) {
      const instance2 = _Sound._pool.pop();
      instance2.init(this.media);
      return instance2;
    }
    return this.media.create();
  }
  /**
   * Destroy/recycling the instance object.
   * @param instance - Instance to recycle
   */
  _poolInstance(instance2) {
    instance2.destroy();
    if (_Sound._pool.indexOf(instance2) < 0) {
      _Sound._pool.push(instance2);
    }
  }
};
var Sound2 = _Sound;
Sound2._pool = [];

// node_modules/@pixi/sound/lib/webaudio/WebAudioContext.mjs
var WebAudioContext = class _WebAudioContext extends Filterable {
  constructor() {
    const win = window;
    const ctx = new _WebAudioContext.AudioContext();
    const compressor = ctx.createDynamicsCompressor();
    const analyser = ctx.createAnalyser();
    analyser.connect(compressor);
    compressor.connect(ctx.destination);
    super(analyser, compressor);
    this.autoPause = true;
    this._ctx = ctx;
    this._offlineCtx = new _WebAudioContext.OfflineAudioContext(
      1,
      2,
      win.OfflineAudioContext ? Math.max(8e3, Math.min(96e3, ctx.sampleRate)) : 44100
    );
    this.compressor = compressor;
    this.analyser = analyser;
    this.events = new eventemitter3_default();
    this.volume = 1;
    this.speed = 1;
    this.muted = false;
    this.paused = false;
    this._locked = ctx.state === "suspended" && ("ontouchstart" in globalThis || "onclick" in globalThis);
    if (this._locked) {
      this._unlock();
      this._unlock = this._unlock.bind(this);
      document.addEventListener("mousedown", this._unlock, true);
      document.addEventListener("touchstart", this._unlock, true);
      document.addEventListener("touchend", this._unlock, true);
    }
    this.onFocus = this.onFocus.bind(this);
    this.onBlur = this.onBlur.bind(this);
    globalThis.addEventListener("focus", this.onFocus);
    globalThis.addEventListener("blur", this.onBlur);
  }
  /** Handle mobile WebAudio context resume */
  onFocus() {
    if (!this.autoPause) {
      return;
    }
    const state = this._ctx.state;
    if (state === "suspended" || state === "interrupted" || !this._locked) {
      this.paused = this._pausedOnBlur;
      this.refreshPaused();
    }
  }
  /** Handle mobile WebAudio context suspend */
  onBlur() {
    if (!this.autoPause) {
      return;
    }
    if (!this._locked) {
      this._pausedOnBlur = this._paused;
      this.paused = true;
      this.refreshPaused();
    }
  }
  /**
   * Try to unlock audio on iOS. This is triggered from either WebAudio plugin setup (which will work if inside of
   * a `mousedown` or `touchend` event stack), or the first document touchend/mousedown event. If it fails (touchend
   * will fail if the user presses for too long, indicating a scroll event instead of a click event.
   *
   * Note that earlier versions of iOS supported `touchstart` for this, but iOS9 removed this functionality. Adding
   * a `touchstart` event to support older platforms may preclude a `mousedown` even from getting fired on iOS9, so we
   * stick with `mousedown` and `touchend`.
   */
  _unlock() {
    if (!this._locked) {
      return;
    }
    this.playEmptySound();
    if (this._ctx.state === "running") {
      document.removeEventListener("mousedown", this._unlock, true);
      document.removeEventListener("touchend", this._unlock, true);
      document.removeEventListener("touchstart", this._unlock, true);
      this._locked = false;
    }
  }
  /**
   * Plays an empty sound in the web audio context.  This is used to enable web audio on iOS devices, as they
   * require the first sound to be played inside of a user initiated event (touch/click).
   */
  playEmptySound() {
    const source = this._ctx.createBufferSource();
    source.buffer = this._ctx.createBuffer(1, 1, 22050);
    source.connect(this._ctx.destination);
    source.start(0, 0, 0);
    if (source.context.state === "suspended") {
      source.context.resume();
    }
  }
  /**
   * Get AudioContext class, if not supported returns `null`
   * @type {AudioContext}
   * @readonly
   */
  static get AudioContext() {
    const win = window;
    return win.AudioContext || win.webkitAudioContext || null;
  }
  /**
   * Get OfflineAudioContext class, if not supported returns `null`
   * @type {OfflineAudioContext}
   * @readonly
   */
  static get OfflineAudioContext() {
    const win = window;
    return win.OfflineAudioContext || win.webkitOfflineAudioContext || null;
  }
  /** Destroy this context. */
  destroy() {
    super.destroy();
    const ctx = this._ctx;
    if (typeof ctx.close !== "undefined") {
      ctx.close();
    }
    globalThis.removeEventListener("focus", this.onFocus);
    globalThis.removeEventListener("blur", this.onBlur);
    this.events.removeAllListeners();
    this.analyser.disconnect();
    this.compressor.disconnect();
    this.analyser = null;
    this.compressor = null;
    this.events = null;
    this._offlineCtx = null;
    this._ctx = null;
  }
  /**
   * The WebAudio API AudioContext object.
   * @readonly
   * @type {AudioContext}
   */
  get audioContext() {
    return this._ctx;
  }
  /**
   * The WebAudio API OfflineAudioContext object.
   * @readonly
   * @type {OfflineAudioContext}
   */
  get offlineContext() {
    return this._offlineCtx;
  }
  /**
   * Pauses all sounds, even though we handle this at the instance
   * level, we'll also pause the audioContext so that the
   * time used to compute progress isn't messed up.
   * @default false
   */
  set paused(paused) {
    if (paused && this._ctx.state === "running") {
      this._ctx.suspend();
    } else if (!paused && this._ctx.state === "suspended") {
      this._ctx.resume();
    }
    this._paused = paused;
  }
  get paused() {
    return this._paused;
  }
  /** Emit event when muted, volume or speed changes */
  refresh() {
    this.events.emit("refresh");
  }
  /** Emit event when muted, volume or speed changes */
  refreshPaused() {
    this.events.emit("refreshPaused");
  }
  /**
   * Toggles the muted state.
   * @return The current muted state.
   */
  toggleMute() {
    this.muted = !this.muted;
    this.refresh();
    return this.muted;
  }
  /**
   * Toggles the paused state.
   * @return The current muted state.
   */
  togglePause() {
    this.paused = !this.paused;
    this.refreshPaused();
    return this._paused;
  }
  /**
   * Decode the audio data
   * @param arrayBuffer - Buffer from loader
   * @param callback - When completed, error and audioBuffer are parameters.
   */
  decode(arrayBuffer, callback) {
    const handleError = (err) => {
      callback(new Error((err == null ? void 0 : err.message) || "Unable to decode file"));
    };
    const result = this._offlineCtx.decodeAudioData(
      arrayBuffer,
      (buffer) => {
        callback(null, buffer);
      },
      handleError
    );
    if (result) {
      result.catch(handleError);
    }
  }
};

// node_modules/@pixi/sound/lib/SoundLibrary.mjs
var SoundLibrary = class {
  constructor() {
    this.init();
  }
  /**
   * Re-initialize the sound library, this will
   * recreate the AudioContext. If there's a hardware-failure
   * call `close` and then `init`.
   * @return Sound instance
   */
  init() {
    if (this.supported) {
      this._webAudioContext = new WebAudioContext();
    }
    this._htmlAudioContext = new HTMLAudioContext();
    this._sounds = {};
    this.useLegacy = !this.supported;
    return this;
  }
  /**
   * The global context to use.
   * @readonly
   */
  get context() {
    return this._context;
  }
  /**
   * Apply filters to all sounds. Can be useful
   * for setting global planning or global effects.
   * **Only supported with WebAudio.**
   * @example
   * import { sound, filters } from '@pixi/sound';
   * // Adds a filter to pan all output left
   * sound.filtersAll = [
   *     new filters.StereoFilter(-1)
   * ];
   */
  get filtersAll() {
    if (!this.useLegacy) {
      return this._context.filters;
    }
    return [];
  }
  set filtersAll(filtersAll) {
    if (!this.useLegacy) {
      this._context.filters = filtersAll;
    }
  }
  /**
   * `true` if WebAudio is supported on the current browser.
   */
  get supported() {
    return WebAudioContext.AudioContext !== null;
  }
  /**
   * @ignore
   */
  add(source, sourceOptions) {
    if (typeof source === "object") {
      const results = {};
      for (const alias in source) {
        const options2 = this._getOptions(
          source[alias],
          sourceOptions
        );
        results[alias] = this.add(alias, options2);
      }
      return results;
    }
    console.assert(!this._sounds[source], `Sound with alias ${source} already exists.`);
    if (sourceOptions instanceof Sound2) {
      this._sounds[source] = sourceOptions;
      return sourceOptions;
    }
    const options = this._getOptions(sourceOptions);
    const sound2 = Sound2.from(options);
    this._sounds[source] = sound2;
    return sound2;
  }
  /**
   * Internal methods for getting the options object
   * @private
   * @param source - The source options
   * @param overrides - Override default options
   * @return The construction options
   */
  _getOptions(source, overrides) {
    let options;
    if (typeof source === "string") {
      options = { url: source };
    } else if (Array.isArray(source)) {
      options = { url: source };
    } else if (source instanceof ArrayBuffer || source instanceof AudioBuffer || source instanceof HTMLAudioElement) {
      options = { source };
    } else {
      options = source;
    }
    options = { ...options, ...overrides || {} };
    return options;
  }
  /**
   * Do not use WebAudio, force the use of legacy. This **must** be called before loading any files.
   */
  get useLegacy() {
    return this._useLegacy;
  }
  set useLegacy(legacy) {
    this._useLegacy = legacy;
    this._context = !legacy && this.supported ? this._webAudioContext : this._htmlAudioContext;
  }
  /**
   * This disables auto-pause all playback when the window blurs (WebAudio only).
   * This is helpful to keep from playing sounds when the user switches tabs.
   * However, if you're running content within an iframe, this may be undesirable
   * and you should disable (set to `true`) this behavior.
   * @default false
   */
  get disableAutoPause() {
    return !this._webAudioContext.autoPause;
  }
  set disableAutoPause(autoPause) {
    this._webAudioContext.autoPause = !autoPause;
  }
  /**
   * Removes a sound by alias.
   * @param alias - The sound alias reference.
   * @return Instance for chaining.
   */
  remove(alias) {
    this.exists(alias, true);
    this._sounds[alias].destroy();
    delete this._sounds[alias];
    return this;
  }
  /**
   * Set the global volume for all sounds. To set per-sound volume see {@link SoundLibrary#volume}.
   */
  get volumeAll() {
    return this._context.volume;
  }
  set volumeAll(volume) {
    this._context.volume = volume;
    this._context.refresh();
  }
  /**
   * Set the global speed for all sounds. To set per-sound speed see {@link SoundLibrary#speed}.
   */
  get speedAll() {
    return this._context.speed;
  }
  set speedAll(speed) {
    this._context.speed = speed;
    this._context.refresh();
  }
  /**
   * Toggle paused property for all sounds.
   * @return `true` if all sounds are paused.
   */
  togglePauseAll() {
    return this._context.togglePause();
  }
  /**
   * Pauses any playing sounds.
   * @return Instance for chaining.
   */
  pauseAll() {
    this._context.paused = true;
    this._context.refreshPaused();
    return this;
  }
  /**
   * Resumes any sounds.
   * @return Instance for chaining.
   */
  resumeAll() {
    this._context.paused = false;
    this._context.refreshPaused();
    return this;
  }
  /**
   * Toggle muted property for all sounds.
   * @return `true` if all sounds are muted.
   */
  toggleMuteAll() {
    return this._context.toggleMute();
  }
  /**
   * Mutes all playing sounds.
   * @return Instance for chaining.
   */
  muteAll() {
    this._context.muted = true;
    this._context.refresh();
    return this;
  }
  /**
   * Unmutes all playing sounds.
   * @return Instance for chaining.
   */
  unmuteAll() {
    this._context.muted = false;
    this._context.refresh();
    return this;
  }
  /**
   * Stops and removes all sounds. They cannot be used after this.
   * @return Instance for chaining.
   */
  removeAll() {
    for (const alias in this._sounds) {
      this._sounds[alias].destroy();
      delete this._sounds[alias];
    }
    return this;
  }
  /**
   * Stops all sounds.
   * @return Instance for chaining.
   */
  stopAll() {
    for (const alias in this._sounds) {
      this._sounds[alias].stop();
    }
    return this;
  }
  /**
   * Checks if a sound by alias exists.
   * @param alias - Check for alias.
   * @param assert - Whether enable console.assert.
   * @return true if the sound exists.
   */
  exists(alias, assert = false) {
    const exists = !!this._sounds[alias];
    if (assert) {
      console.assert(exists, `No sound matching alias '${alias}'.`);
    }
    return exists;
  }
  /**
   * Convenience function to check to see if any sound is playing.
   * @returns `true` if any sound is currently playing.
   */
  isPlaying() {
    for (const alias in this._sounds) {
      if (this._sounds[alias].isPlaying) {
        return true;
      }
    }
    return false;
  }
  /**
   * Find a sound by alias.
   * @param alias - The sound alias reference.
   * @return Sound object.
   */
  find(alias) {
    this.exists(alias, true);
    return this._sounds[alias];
  }
  /**
   * Plays a sound.
   * @method play
   * @instance
   * @param {string} alias - The sound alias reference.
   * @param {string} sprite - The alias of the sprite to play.
   * @return {IMediaInstance|null} The sound instance, this cannot be reused
   *         after it is done playing. Returns `null` if the sound has not yet loaded.
   */
  /**
   * Plays a sound.
   * @param alias - The sound alias reference.
   * @param {PlayOptions|Function} options - The options or callback when done.
   * @return The sound instance,
   *        this cannot be reused after it is done playing. Returns a Promise if the sound
   *        has not yet loaded.
   */
  play(alias, options) {
    return this.find(alias).play(options);
  }
  /**
   * Stops a sound.
   * @param alias - The sound alias reference.
   * @return Sound object.
   */
  stop(alias) {
    return this.find(alias).stop();
  }
  /**
   * Pauses a sound.
   * @param alias - The sound alias reference.
   * @return Sound object.
   */
  pause(alias) {
    return this.find(alias).pause();
  }
  /**
   * Resumes a sound.
   * @param alias - The sound alias reference.
   * @return Instance for chaining.
   */
  resume(alias) {
    return this.find(alias).resume();
  }
  /**
   * Get or set the volume for a sound.
   * @param alias - The sound alias reference.
   * @param volume - Optional current volume to set.
   * @return The current volume.
   */
  volume(alias, volume) {
    const sound2 = this.find(alias);
    if (volume !== void 0) {
      sound2.volume = volume;
    }
    return sound2.volume;
  }
  /**
   * Get or set the speed for a sound.
   * @param alias - The sound alias reference.
   * @param speed - Optional current speed to set.
   * @return The current speed.
   */
  speed(alias, speed) {
    const sound2 = this.find(alias);
    if (speed !== void 0) {
      sound2.speed = speed;
    }
    return sound2.speed;
  }
  /**
   * Get the length of a sound in seconds.
   * @param alias - The sound alias reference.
   * @return The current duration in seconds.
   */
  duration(alias) {
    return this.find(alias).duration;
  }
  /**
   * Closes the sound library. This will release/destroy
   * the AudioContext(s). Can be used safely if you want to
   * initialize the sound library later. Use `init` method.
   */
  close() {
    this.removeAll();
    this._sounds = null;
    if (this._webAudioContext) {
      this._webAudioContext.destroy();
      this._webAudioContext = null;
    }
    if (this._htmlAudioContext) {
      this._htmlAudioContext.destroy();
      this._htmlAudioContext = null;
    }
    this._context = null;
    return this;
  }
};

// node_modules/@pixi/sound/lib/soundAsset.mjs
var getAlias = (asset) => {
  var _a;
  const src = asset.src;
  let alias = (_a = asset == null ? void 0 : asset.alias) == null ? void 0 : _a[0];
  if (!alias || asset.src === alias) {
    alias = path.basename(src, path.extname(src));
  }
  return alias;
};
var soundAsset = {
  extension: ExtensionType.Asset,
  detection: {
    test: async () => true,
    add: async (formats) => [...formats, ...extensions2.filter((ext) => supported[ext])],
    remove: async (formats) => formats.filter((ext) => formats.includes(ext))
  },
  loader: {
    name: "sound",
    extension: {
      type: [ExtensionType.LoadParser],
      priority: LoaderParserPriority.High
    },
    /** Should we attempt to load this file? */
    test(url) {
      const ext = path.extname(url).slice(1);
      return !!supported[ext] || mimes.some((mime) => url.startsWith(`data:${mime}`));
    },
    /** Load the sound file, this is mostly handled by Sound.from() */
    async load(url, asset) {
      const sound2 = await new Promise((resolve, reject) => Sound2.from({
        ...asset.data,
        url,
        preload: true,
        loaded(err, sound22) {
          var _a, _b;
          if (err) {
            reject(err);
          } else {
            resolve(sound22);
          }
          (_b = (_a = asset.data) == null ? void 0 : _a.loaded) == null ? void 0 : _b.call(_a, err, sound22);
        }
      }));
      getInstance().add(getAlias(asset), sound2);
      return sound2;
    },
    /** Remove the sound from the library */
    async unload(_sound, asset) {
      getInstance().remove(getAlias(asset));
    }
  }
};
extensions.add(soundAsset);

// node_modules/@pixi/sound/lib/index.mjs
var sound = setInstance(new SoundLibrary());

// node_modules/my-pixi-coffee-pixi-game-framework/dist/eventsManager/BaseEvent.js
var BaseEvent = class {
  /**
   * Base event.
   * @param eventType Event type (event name).
   * @param payload Can contain any value or values that you want (optional).
   */
  constructor(eventType, payload) {
    this._eventType = eventType;
    this._payload = payload;
  }
  /**
   * Returns current event type.
   * @returns string
   */
  getEventType() {
    return this._eventType;
  }
  /**
   * Returns current event's payload value.
   * @returns any
   */
  getPayload() {
    return this._payload;
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/eventsManager/PreloaderEvents.js
var PreloaderEvents = class extends BaseEvent {
};
PreloaderEvents.LOADING_BEGIN = "LOADING_BEGIN";
PreloaderEvents.LOADING_PROGRESS = "LOADING_PROGRESS";
PreloaderEvents.LOADING_COMPLETE = "LOADING_COMPLETE";

// node_modules/my-pixi-coffee-pixi-game-framework/dist/Globals.js
var Globals = class {
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/eventsManager/EventsManager.js
var import_signals = __toESM(require_signals(), 1);
var EventsManager = class _EventsManager {
  constructor() {
    this.signals = [];
    this.eventTypes = [];
  }
  /**
   * Returns instance of this class.
   * @returns EventManager
   */
  static getInstance() {
    if (this.instance === void 0) {
      this.instance = new _EventsManager();
    }
    return this.instance;
  }
  /**
   * Adds new event.
   * @param eventType Event type (event name).
   * @param callback Callback function.
   * @param listenerContext This is actually caller class in most cases (optional parameter).
   */
  addEvent(eventType, callback, listenerContext) {
    const signal = new import_signals.Signal();
    signal.add(callback, listenerContext);
    this.signals.push(signal);
    this.eventTypes.push(eventType);
  }
  /**
   * Removes the event.
   * The event will be removed only if it already exists.
   * @param eventType Event type (event name).
   * @param callback Callback function.
   * @param listenerContext This is actually caller class in most cases (optional parameter).
   */
  removeEvent(eventType, callback, listenerContext) {
    if (this.hasEvent(eventType)) {
      let index = -1;
      for (let i = 0; i < this.eventTypes.length; i++) {
        const eventItem = this.eventTypes[i];
        if (eventItem === eventType) {
          const signal = this.signals[i];
          if (signal.has(callback, listenerContext)) {
            signal.remove(callback, listenerContext);
            index = i;
          }
        }
      }
      if (index > -1) {
        this.signals.splice(index, 1);
        this.eventTypes.splice(index, 1);
      }
    }
  }
  /**
   * Checks does event exists.
   * @param eventType Event type (event name).
   * @returns boolean
   */
  hasEvent(eventType) {
    return this.eventTypes.indexOf(eventType) > -1;
  }
  /**
   * Dispatches the event.
   * The event will be dispatched only if it exists.
   * @param event BaseEvent object.
   */
  dispatchEvent(event) {
    const eventType = event.getEventType();
    if (this.hasEvent(eventType)) {
      for (let i = 0; i < this.eventTypes.length; i++) {
        const eventItem = this.eventTypes[i];
        if (eventItem === eventType) {
          const signal = this.signals[i];
          signal.dispatch(event);
        }
      }
    }
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/managers/events/orientationTypes.js
var OrientationTypes;
(function(OrientationTypes2) {
  OrientationTypes2[OrientationTypes2["PORTRAIT"] = 1] = "PORTRAIT";
  OrientationTypes2[OrientationTypes2["LANDSCAPE"] = 2] = "LANDSCAPE";
  OrientationTypes2[OrientationTypes2["NONE"] = 3] = "NONE";
})(OrientationTypes || (OrientationTypes = {}));

// node_modules/my-pixi-coffee-pixi-game-framework/dist/managers/events/deviceManager.js
var DeviceManager = class _DeviceManager {
  constructor() {
    this._isInFullscreen = false;
  }
  /**
   * Updates the network status.
   * Listens for online/offline status.
   */
  updateNetworkStatus() {
  }
  /**
   * Adds all necessary events.
   * Dispatches the events like visibility change or offline/online status.
   */
  addNecessaryEvents() {
    window.addEventListener("online", this.updateNetworkStatus);
    window.addEventListener("offline", this.updateNetworkStatus);
    document.addEventListener("fullscreenchange", this.onFullScreenChange, false);
    document.addEventListener("webkitfullscreenchange", this.onFullScreenChange, false);
    document.addEventListener("mozfullscreenchange", this.onFullScreenChange, false);
  }
  onFullScreenChange() {
    this._isInFullscreen = document.fullscreenElement !== void 0;
  }
  /**
   * Requests the fullscreen for specific DOM element.
   * @param element HTML DOM element that will be presented in fullscreen.
   */
  requestFullScreen(element) {
    if (!this._isInFullscreen && document.fullscreenEnabled) {
      element.requestFullscreen();
    }
  }
  /**
   * Returns to regular screen (exit from fullscreen mode).
   */
  exitFullScreen() {
    if (this._isInFullscreen && document.fullscreenEnabled) {
      document.exitFullscreen();
    }
  }
  /**
   * Toggles the fullscreen state.
   * @param element HTML DOM element that will be presented in fullscreen.
   */
  toggleFullScreen(element) {
    if (document.fullscreenEnabled) {
      if (!this._isInFullscreen) {
        element.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    }
  }
  /**
   * Returns the instance of this class.
   * @returns DeviceManager
   */
  static getInstance() {
    if (this._instance === void 0) {
      this._instance = new _DeviceManager();
    }
    return this._instance;
  }
  /**
   * Determines is it android device.
   * @returns boolean
   */
  isAndroid() {
    return !!navigator.userAgent.match(/Android/i);
  }
  /**
   * Determines is it WebOS device.
   * @returns boolean
   */
  isWebOS() {
    return !!navigator.userAgent.match(/webOS/i);
  }
  /**
   * Determines is it BlackBerry device.
   * @returns boolean
   */
  isBlackBerry() {
    return !!navigator.userAgent.match(/BlackBerry/i);
  }
  /**
   * Determines is it iOS device.
   * @returns boolean
   */
  isIOS() {
    return !!navigator.userAgent.match(/iPhone|iPad|iPod/i);
  }
  /**
   * Determines is it Opera device.
   * @returns boolean
   */
  isOpera() {
    return !!navigator.userAgent.match(/Opera Mini/i);
  }
  /**
   * Determines is it Windows phone device.
   * @returns boolean
   */
  isWindowsPhone() {
    return !!navigator.userAgent.match(/IEMobile|Windows Phone/i);
  }
  /**
   * Determines is it mobile device (phone, tablet).
   * @returns boolean
   */
  isMobile() {
    return this.isAndroid() || this.isWebOS() || this.isBlackBerry() || this.isIOS() || this.isOpera() || this.isWindowsPhone();
  }
  /**
   * Calculates and returns device's aspect ratio.
   * @returns Device's aspect ratio value.
   */
  getAspectRatio() {
    return (window.innerWidth / window.innerHeight).toFixed(2);
  }
  /**
   * Returns device's current orientation type.
   * @returns OrientationTypes enum value.
   */
  getOrientation() {
    if (window.orientation !== void 0) {
      return window.orientation === 0 ? OrientationTypes.PORTRAIT : OrientationTypes.LANDSCAPE;
    }
    return OrientationTypes.NONE;
  }
  /**
   * Returns browser's name (Opera, IE, Chrome, Safari, Firefox).
   * @returns string
   */
  getBrowserName() {
    const nAgt = navigator.userAgent;
    let browserName = navigator.appName;
    if (nAgt.indexOf("Opera") !== -1) {
      browserName = "Opera";
    } else if (nAgt.indexOf("MSIE") !== -1) {
      browserName = "IE";
    } else if (nAgt.indexOf("Chrome") !== -1) {
      browserName = "Chrome";
    } else if (nAgt.indexOf("Safari") !== -1) {
      browserName = "Safari";
    } else if (nAgt.indexOf("Firefox") !== -1) {
      browserName = "Firefox";
    } else if (nAgt.lastIndexOf(" ") + 1 < nAgt.lastIndexOf("/")) {
      const nameOffset = nAgt.lastIndexOf(" ") + 1;
      const verOffset = nAgt.lastIndexOf("/");
      browserName = nAgt.substring(nameOffset, verOffset);
    }
    return browserName;
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/data/Preloader.js
var Preloader = class {
  constructor() {
    this.assetsName = "game-assets";
    this.manifestName = "./assets-manifest.json";
    this.gameFolder = "";
    this.device = DeviceManager.getInstance().isMobile() ? "mobile" : "desktop";
    this.loadManifest(this.updateProgress);
  }
  async loadManifest(onProgress) {
    console.log("LOAD MANIFEST....");
    const basePath = window.location.pathname.replace(/\/[^\/]*$/, "/") + "assets/";
    try {
      const manifestResponse = await fetch(this.manifestName);
      if (!manifestResponse.ok)
        throw new Error(`Failed to load manifest: ${manifestResponse.status}`);
      const manifest = await manifestResponse.json();
      console.log("MANIFEST: ", manifest);
      const loadDataHolder = [];
      const soundAssets = [];
      let totalSoundAssets = 0;
      manifest.bundles.forEach((bundle) => {
        bundle.assets.forEach((asset) => {
          asset.src = basePath + asset.src;
          Assets.add(asset);
          loadDataHolder.push(asset.id);
          if (asset.src.endsWith(".mp3") || asset.src.endsWith(".ogg") || asset.src.endsWith(".wav")) {
            asset.type = "audio";
            totalSoundAssets++;
          }
        });
      });
      console.log("Loading.................................");
      let texturesData;
      try {
        texturesData = await Assets.load(loadDataHolder, (val) => {
          this.updateProgress(val * 0.8);
        });
      } catch (error) {
        console.error("Error while loading assets:", error);
      }
      Globals.assetsLibrary = texturesData;
      console.log("Textures Loaded:", texturesData);
      console.log(" Game Assets Loaded:");
      let loadedSoundAssets = 0;
      const soundPromises = [];
      manifest.bundles.forEach((bundle) => {
        bundle.assets.forEach((asset) => {
          if (asset.src.endsWith(".mp3") || asset.src.endsWith(".ogg") || asset.src.endsWith(".wav")) {
            const soundPromise = new Promise((resolve) => {
              const sound2 = Sound2.from(asset.src);
              soundAssets.push({ name: asset.id, sound: sound2 });
              setTimeout(() => {
                loadedSoundAssets++;
                const progress = Math.min(1, 0.8 + loadedSoundAssets / totalSoundAssets * 0.2);
                onProgress(progress);
                resolve();
              }, 20);
            });
            soundPromises.push(soundPromise);
          }
        });
      });
      await Promise.all(soundPromises);
      Globals.SoundAssets = soundAssets;
      console.log(" All Sounds Loaded:", soundAssets);
      EventsManager.getInstance().dispatchEvent(new PreloaderEvents(PreloaderEvents.LOADING_COMPLETE));
      return { soundAssets };
    } catch (e) {
    }
  }
  updateProgress(progress) {
    EventBus_default.emit(GameStatus.LOADING, { value: progress });
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/events/EventsEnum.js
var EventsEnum;
(function(EventsEnum2) {
  EventsEnum2["INITIAL_DATA"] = "INITIAL_DATA";
  EventsEnum2["SPIN"] = "SPIN";
  EventsEnum2["STOP_SPIN"] = "STOP_SPIN";
  EventsEnum2["START_SPIN"] = "START_SPIN";
  EventsEnum2["STOP"] = "STOP";
  EventsEnum2["REEL_STOPPED"] = "REEL_STOPPED";
  EventsEnum2["AUTOSPIN"] = "AUTOSPIN";
  EventsEnum2["IDLE"] = "IDLE";
  EventsEnum2["UI_STATE"] = "UI_STATE";
  EventsEnum2["STATE_CHANGED"] = "STATE_CHANGED";
  EventsEnum2["CHEAT_SERVER_COMMAND"] = "CHEAT_SERVER_COMMAND";
  EventsEnum2["SYMBOL_TRANSFORM"] = "SYMBOL_TRANSFORM";
  EventsEnum2["SYMBOL_TRANSFORM_BACK"] = "SYMBOL_TRANSFORM_BACK";
  EventsEnum2["MOCK_DATA"] = "MOCK_DATA";
  EventsEnum2["UPDATE_GAME_STATE"] = "UPDATE_GAME_STATE";
  EventsEnum2["SHOW_IN_COINS"] = "SHOW_IN_COINS";
  EventsEnum2["COUNTER_DONE"] = "COUNTER_DONE";
  EventsEnum2["QUICK_SPIN"] = "QUICK_SPIN";
  EventsEnum2["ANTICIPATION"] = "ANTICIPATION";
})(EventsEnum || (EventsEnum = {}));

// node_modules/my-pixi-coffee-pixi-game-framework/dist/managers/SoundManager.js
var import_howler = __toESM(require_howler(), 1);

// node_modules/my-pixi-coffee-pixi-game-framework/dist/sound/SoundId.js
var SoundId = class {
  constructor() {
  }
  getBigWinSound(winType) {
    let bigWinSoundId = "";
    switch (winType) {
      case "big":
        bigWinSoundId = "bigWin";
        break;
      case "mega":
        bigWinSoundId = "megaWin";
        break;
      case "super":
        bigWinSoundId = "sensationalWin";
        break;
      case "epic":
        bigWinSoundId = "epicWin";
        break;
    }
    return bigWinSoundId;
  }
  getRegularWinId() {
    return "regularWin";
  }
  getCollectWinId() {
    return "collectWin";
  }
};
SoundId.MAIN_THEME = "mainTheme";
SoundId.AMBIENT_MUSIC = "mainMusic";

// node_modules/my-pixi-coffee-pixi-game-framework/dist/managers/SoundManager.js
var SoundManager = class {
  constructor(soundData) {
    this.bcgMusicState = 1;
    this.soundData = soundData;
    document.addEventListener("visibilitychange", () => {
      if (this.gameMusic && this.bcgMusicState === 1) {
        if (document.visibilityState === "hidden" && Globals.gameStates.getIsGameEntered()) {
          this.gameMusic.pause();
        } else {
          if (!Globals.gameStates.getIsSoundOn())
            return;
          this.gameMusic.play();
        }
      }
      if (this.ambientMusic && this.bcgMusicState === 2) {
        if (document.visibilityState === "hidden" && Globals.gameStates.getIsGameEntered()) {
          this.ambientMusic.pause();
        } else {
          if (!Globals.gameStates.getIsSoundOn())
            return;
          this.ambientMusic.play();
        }
      }
    });
    window.addEventListener("focus", () => {
      if (!Globals.gameStates.getIsSoundOn())
        return;
    });
    window.addEventListener("blur", () => {
    });
    EventBus_default.on(EventsEnum.COUNTER_DONE, () => {
      if (this.gameMusic) {
        this.gameMusic.fade(0.1, 0.5, 1e3);
      }
    });
  }
  handleUiAction(isSoundOn) {
    if (!Globals.gameStates.getIsGameEntered())
      return;
    if (isSoundOn) {
      if (this.gameMusic) {
        if (!this.gameMusic.playing()) {
          this.gameMusic.play();
        } else {
          this.playMusic(SoundId.MAIN_THEME);
        }
      } else {
        this.playMusic(SoundId.MAIN_THEME);
      }
    } else {
      this.stopMusic();
      this.stopAmbientMusic();
    }
  }
  playMusic(musicId) {
    if (!Globals.gameStates.getIsSoundOn() || !Globals.gameStates.getIsGameSoundsOn() || !Globals.gameStates.getIsGameEntered())
      return;
    this.bcgMusicState = 1;
    const snd = this.soundData.find((s) => s.name === musicId).sound.url;
    if (this.gameMusic) {
      this.gameMusic.stop();
    }
    this.gameMusic = new import_howler.Howl({
      src: [snd],
      autoplay: true,
      loop: true,
      volume: 0.5
    });
  }
  stopMusic() {
    if (this.gameMusic) {
      this.gameMusic.stop();
    }
  }
  playSound(soundId) {
    var _a;
    if (this.gameMusic) {
      this.gameMusic.fade(0.5, 0.1, 500);
    }
    if (!Globals.gameStates.getIsSoundOn() || !Globals.gameStates.getIsGameSoundsOn())
      return;
    const clickSound = (_a = this.soundData.find((s) => s.name === soundId)) === null || _a === void 0 ? void 0 : _a.sound;
    clickSound === null || clickSound === void 0 ? void 0 : clickSound.play();
  }
  stopSound(soundId) {
    var _a;
    const clickSound = (_a = this.soundData.find((s) => s.name === soundId)) === null || _a === void 0 ? void 0 : _a.sound;
    clickSound === null || clickSound === void 0 ? void 0 : clickSound.stop();
  }
  playAmbientMusic(val) {
    if (!Globals.gameStates.getIsSoundOn() || !Globals.gameStates.getIsAmbientSound() || !Globals.gameStates.getIsGameEntered())
      return;
    if (val) {
      this.bcgMusicState = 2;
      this.stopMusic();
      const snd = this.soundData.find((s) => s.name === SoundId.AMBIENT_MUSIC).sound.url;
      if (this.ambientMusic) {
        this.ambientMusic.stop();
      }
      this.ambientMusic = new import_howler.Howl({
        src: [snd],
        autoplay: true,
        loop: true,
        volume: 0.5
      });
      this.ambientMusic.play();
    } else {
      this.stopAmbientMusic();
    }
  }
  stopAmbientMusic() {
    if (this.ambientMusic) {
      this.ambientMusic.stop();
    }
  }
  gameSoundsAction(value) {
    if (!value) {
      this.stopMusic();
    } else {
      this.playMusic(SoundId.MAIN_THEME);
    }
  }
  playCollectWinSound(soundId) {
    if (!Globals.gameStates.getIsSoundOn() || Globals.gameStates.getIsAmbientSound())
      return;
    if (!this.collectSound) {
      const snd = this.soundData.find((s) => s.name === soundId).sound.url;
      this.collectSound = new import_howler.Howl({
        src: [snd]
      });
    }
    if (!this.collectSound.playing()) {
      this.collectSound.play();
    }
  }
  playIndependentSound(soundId) {
    if (!Globals.gameStates.getIsSoundOn() || Globals.gameStates.getIsAmbientSound())
      return;
    const snd = this.soundData.find((s) => s.name === soundId).sound.url;
    const newSound = new import_howler.Howl({
      src: [snd]
    });
    newSound.play();
    newSound.once("end", () => {
      newSound.unload();
    });
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/factory/SpriteSheetFactory.js
var SpriteSheetFactory = class {
  constructor() {
  }
  getSpriteSheetAnimation(spriteSheetId, animationName) {
    const animations = Assets.cache.get(spriteSheetId).data.animations;
    const card = AnimatedSprite.fromFrames(animations[animationName]);
    return card;
  }
  // @ts-ignore
  getSpriteSheetImage(spriteSheetId, imageName) {
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/factory/GameFactory.js
var GameFactory = class {
  constructor(container, soundData) {
    this.mainContainer = container;
    Globals.gameComponentsHolder = new GameComponentsHolder();
    Globals.gameStates = new GameStates();
    Globals.soundIdManager = new SoundId();
    Globals.soundManager = new SoundManager(soundData);
    this.gameConfiguration = new GameConfig();
    Globals.gameConfig = this.gameConfiguration;
    Globals.spritesheetFactory = new SpriteSheetFactory();
    this.setupGameConfiguration();
  }
  setupGameConfiguration() {
  }
  setup() {
    this.gameController = new BaseGameController(this.gameConfiguration);
  }
  // @ts-ignore
  createGameBackground() {
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/GameProperties.js
var GameProperties = class {
};
GameProperties.STAGE_WIDTH = 1920;
GameProperties.STAGE_HEIGHT = 1080;
GameProperties.DEV_COMMUNICATION_URL = "http://localhost:3006";
GameProperties.GUIDES_ON = false;

// node_modules/my-pixi-coffee-pixi-game-framework/dist/managers/ScreenManager.js
var ScreenManager = class {
  constructor(app, gameContainer) {
    this.currentScene = null;
    this.scenes = /* @__PURE__ */ new Map();
    this.app = app;
    this.gameContainer = gameContainer;
    this.app.ticker.add((delta) => {
      var _a;
      if ((_a = this.currentScene) === null || _a === void 0 ? void 0 : _a.update) {
        this.currentScene.update(delta.deltaTime);
      }
    });
    window.addEventListener("resize", () => {
      if (!this.currentScene)
        return;
      const isLandscape = window.innerWidth > window.innerHeight;
      const width = window.innerWidth;
      const height = window.innerHeight;
      const isMobile = /Mobi|Android/i.test(navigator.userAgent);
      this.currentScene.orientationChange(isLandscape, isMobile, width, height);
    });
  }
  /** Register a scene with a unique name */
  registerScene(scene) {
    this.scenes.set(scene.sceneName, scene);
  }
  /** Switch to a scene by name */
  changeScene(sceneName) {
    const scene = this.scenes.get(sceneName);
    if (!scene) {
      console.warn(`Scene ${sceneName} not found!`);
      return;
    }
    if (this.currentScene) {
      this.currentScene.onHide();
      this.gameContainer.removeChild(this.currentScene);
    }
    this.currentScene = scene;
    this.gameContainer.addChild(scene);
    scene.onShow();
    const isLandscape = window.innerWidth > window.innerHeight;
    const width = window.innerWidth;
    const height = window.innerHeight;
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
    scene.orientationChange(isLandscape, isMobile, width, height);
  }
  /** Get current scene instance */
  getCurrentScene() {
    return this.currentScene;
  }
  getSceneById(id3) {
    return this.scenes.get(id3);
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/managers/PositionManager.js
var PositionManager = class {
  constructor(baseUrl = "/") {
    this.dataMap = /* @__PURE__ */ new Map();
    this.assetsBaseUrl = "/";
    this.assetsBaseUrl = baseUrl;
  }
  /** Load JSON data from /public/GameLayout.json */
  async loadPositionData() {
    try {
      console.log("Fetching JSON from:", `${this.assetsBaseUrl}GameLayout.json`);
      const response = await fetch(`${this.assetsBaseUrl}GameLayout.json`);
      if (!response.ok) {
        throw new Error(`Failed to fetch GameLayout.json: ${response.statusText}`);
      }
      const data = await response.json();
      this.parseData(data);
      return data;
    } catch (error) {
      console.error("Error loading position data:", error);
      throw error;
    }
  }
  test() {
    console.log("TEST", this.dataMap);
  }
  getItemPosition(key) {
    return this.dataMap.get(key);
  }
  setItemPositionAndScale(item, positionKey) {
    const pData = this.dataMap.get(positionKey);
    if (!pData)
      throw new Error(`No data with id ${positionKey}`);
    item.x = pData.x;
    item.y = pData.y;
    item.width = pData.width;
    item.height = pData.height;
  }
  parseData(data) {
    for (const element of data.elements) {
      this.dataMap.set(element.name, element);
    }
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/data/SceneNames.js
var SceneNames = {
  LoadingScene: "LoadingScene",
  GameScene: "GameScene",
  EndGameScene: "EndGameScene",
  StartScreen: "StartScreen"
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/Game.js
var GameApplication = class {
  constructor(w, h, color, fromGame = false) {
    var _a, _b;
    this.isHelpLayer = true;
    this.helperAlpha = 0.5;
    this.isHelperVisible = true;
    this.soundAssets = [];
    this.gameInstanceName = "CoffeeBreakGameInstance";
    this.isFromGame = false;
    this.isFromGame = fromGame;
    const globalWindow = window;
    if (globalWindow[this.gameInstanceName]) {
      (_b = (_a = globalWindow[this.gameInstanceName]).destroy) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    globalWindow[this.gameInstanceName] = this;
    this.app = new Application();
    const init = async () => {
      await this.app.init({
        width: w,
        height: h,
        background: color,
        resizeTo: window,
        resolution: window.devicePixelRatio || 1,
        autoDensity: true
      });
      const gameContainer = document.getElementById("pixi-game-container");
      gameContainer.appendChild(this.app.canvas);
      GameProperties.STAGE_WIDTH = w;
      GameProperties.STAGE_HEIGHT = h;
      this.gameContainer = new Container();
      this.app.stage.addChild(this.gameContainer);
      this.screenManager = new ScreenManager(this.app, this.gameContainer);
    };
    init();
  }
  async start() {
    Globals.positionManager = new PositionManager();
    await Globals.positionManager.loadPositionData();
    EventsManager.getInstance().addEvent(PreloaderEvents.LOADING_COMPLETE, this.setupGame, this);
    this.createMainScreens();
    EventBus_default.on("START_GAME", () => {
      this.screenManager.changeScene(SceneNames.GameScene);
    });
    this.screenManager.changeScene(SceneNames.LoadingScene);
    EventBus_default.on(GameStatus.LOADING, (progress) => {
      const loadScene = this.screenManager.getSceneById(SceneNames.LoadingScene);
      loadScene.updateProgress(progress.value);
    });
    const preload = new Preloader();
  }
  createMainScreens() {
    const loadingScene = new LoadingScene(SceneNames.LoadingScene, this.gameContainer);
    const startScreen = new StartScreen(SceneNames.StartScreen, this.gameContainer);
    const gameScene = new GameScene(SceneNames.GameScene, this.gameContainer);
    this.screenManager.registerScene(loadingScene);
    this.screenManager.registerScene(startScreen);
    this.screenManager.registerScene(gameScene);
  }
  setupGame() {
    console.log("---------------------- SETUP GAME --------------------");
    if (this.preloader) {
      this.app.stage.removeChild(this.preloader);
      this.preloader.destroy({ children: true });
    }
    EventsManager.getInstance().removeEvent(PreloaderEvents.LOADING_COMPLETE, this.setupGame, this);
    const gameFactory = new GameFactory(this.gameContainer, this.soundAssets);
    gameFactory.setup();
    if (this.isHelpLayer) {
      this.createHelpLayer(Globals.gameStates.getIsLandscapeState());
    }
    this.gameReady();
  }
  async gameReady() {
    console.log("---- GAME READY ------");
    this.screenManager.changeScene(SceneNames.StartScreen);
    window.addEventListener("resize", () => {
      this.onResize();
    });
    this.onResize();
  }
  createHelpLayer(isLandscape) {
    this.helpLayer = new Graphics();
    this.helpLayer.rect(0, 0, isLandscape ? 1920 : 1080, isLandscape ? 1080 : 1920).fill({ alpha: this.helperAlpha, color: 16711680 });
    this.helpLayer.visible = this.isHelperVisible;
    this.gameContainer.addChild(this.helpLayer);
  }
  revriteHelper(isLandscape) {
    if (this.isHelpLayer) {
      this.helpLayer.x = 0;
      this.helpLayer.y = 0;
      this.helpLayer.clear();
      this.helpLayer.rect(0, 0, isLandscape ? 1920 : 1080, isLandscape ? 1080 : 1920).fill({ alpha: this.helperAlpha, color: 16711680 });
    }
  }
  onResize() {
    const targetAspectRatio = 16 / 9;
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    const isLandscape = windowWidth > windowHeight;
    Globals.gameStates.setIsLandscapeState(isLandscape);
    Globals.gameStates.setOrientationState(isLandscape ? Orientation.LANDSCAPE : Orientation.PORTRAIT);
    const windowAspectRatio = windowWidth / windowHeight;
    let defaultWidth = GameProperties.STAGE_WIDTH;
    let defaultHeight = GameProperties.STAGE_HEIGHT;
    if (!isLandscape) {
      [defaultWidth, defaultHeight] = [defaultHeight, defaultWidth];
    }
    let newWidth, newHeight;
    if (windowAspectRatio > targetAspectRatio) {
      newHeight = windowHeight;
      newWidth = newHeight * targetAspectRatio;
    } else {
      newWidth = windowWidth;
      newHeight = newWidth / targetAspectRatio;
    }
    this.app.renderer.resize(windowWidth, windowHeight);
    const scale = windowWidth / windowHeight > defaultWidth / defaultHeight ? windowHeight / defaultHeight : windowWidth / defaultWidth;
    this.gameContainer.scale.set(scale, scale);
    Globals.gameScale = scale;
    if (isLandscape) {
      this.gameContainer.x = (windowWidth - 1920 * scale) / 2;
      this.gameContainer.y = (windowHeight - 1080 * scale) / 2;
    } else {
      this.gameContainer.x = (windowWidth - 1080 * scale) / 2;
      this.gameContainer.y = (windowHeight - 1920 * scale) / 2;
    }
    this.revriteHelper(Globals.gameStates.getIsLandscapeState());
    Globals.gameComponentsHolder.onResize(Globals.gameStates.getIsLandscapeState(), Globals.gameStates.getIsMobile(), newWidth, newHeight);
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/managers/events/deviceManagerEvents.js
var DeviceManagerEvents = class extends BaseEvent {
};
DeviceManagerEvents.ON_VISIBILITY_CHANGE = "DM:ON_VISIBILITY_CHANGE";
DeviceManagerEvents.ON_NETWORK_STATUS_CHANGE = "DM:ON_NETWORK_STATUS_CHANGE";

// node_modules/my-pixi-coffee-pixi-game-framework/dist/statemachine/BaseState.js
var BaseState = class {
  constructor(stateName) {
    this.state = stateName;
    this.isExit = false;
  }
  enter() {
    this.isExit = false;
    console.log("ENTER BASE STATE");
    EventBus_default.emit(EventsEnum.IDLE, {});
  }
  exit() {
    if (this.isExit)
      return;
    this.isExit = true;
    console.log("EXIT BASE STATE");
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/statemachine/data/SlotMachineStates.js
var SlotMachineStates;
(function(SlotMachineStates2) {
  SlotMachineStates2[SlotMachineStates2["INTRO"] = 0] = "INTRO";
  SlotMachineStates2[SlotMachineStates2["MAIN_MENU"] = 1] = "MAIN_MENU";
  SlotMachineStates2[SlotMachineStates2["GAME"] = 2] = "GAME";
  SlotMachineStates2[SlotMachineStates2["END_GAME"] = 3] = "END_GAME";
})(SlotMachineStates || (SlotMachineStates = {}));

// node_modules/my-pixi-coffee-pixi-game-framework/dist/statemachine/data/StateHolder.js
var StateHolder = class _StateHolder {
  constructor() {
    this.statesData = /* @__PURE__ */ new Map();
    this.presentationStates = [];
  }
  static getInstance() {
    if (!_StateHolder.instance) {
      _StateHolder.instance = new _StateHolder();
    }
    return _StateHolder.instance;
  }
  setState(id3, state) {
    this.statesData.set(id3, state);
  }
  getState(id3) {
    return this.statesData.get(id3);
  }
  setPresentationStates(state) {
    this.presentationStates.push(state);
  }
  getPresentationStates() {
    return this.presentationStates;
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/statemachine/StateMachine.js
var StateMachine = class {
  constructor() {
    this.currentState = null;
    this.checkingStates = [];
    this.checkingCounter = 0;
    StateHolder.getInstance().setState(SlotMachineStates.INTRO, new BaseState(SlotMachineStates.INTRO));
    EventBus_default.on(EventsEnum.UI_STATE, (data) => {
      console.log(data);
    });
    EventBus_default.on(EventsEnum.UPDATE_GAME_STATE, (data) => {
    });
  }
  async changeState(newState, data) {
    var _a;
    this.currentState = newState;
    if (((_a = this.currentState) === null || _a === void 0 ? void 0 : _a.state) !== SlotMachineStates.INTRO) {
      this.handleStates(data);
    } else {
      this.currentState.enter(data);
    }
    EventBus_default.emit(EventsEnum.STATE_CHANGED, { state: this.currentState.state });
  }
  startCheckingStates(checking, data) {
    this.checkingStates = checking;
    this.checkingCounter = 0;
    const state = this.checkingStates[this.checkingCounter];
    this.checkingCounter++;
    this.changeState(state, data);
  }
  getSate() {
    return this.currentState;
  }
  async handleStates(data) {
    var _a;
    await ((_a = this.currentState) === null || _a === void 0 ? void 0 : _a.enter(data));
    if (this.checkingCounter < this.checkingStates.length) {
      const state = this.checkingStates[this.checkingCounter];
      this.checkingCounter++;
      this.changeState(state);
    } else {
    }
  }
};

// node_modules/my-pixi-coffee-pixi-game-framework/dist/utils/Utils.js
function pause(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function cancelablePause(ms) {
  let timeoutId;
  let rejectFn;
  const promise = new Promise((resolve, reject) => {
    rejectFn = reject;
    timeoutId = setTimeout(resolve, ms);
  });
  return {
    promise,
    cancel: () => {
      clearTimeout(timeoutId);
      rejectFn === null || rejectFn === void 0 ? void 0 : rejectFn("cancelled");
    }
  };
}
function shuffleArray(array) {
  const result = array.slice();
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
}
export {
  AssetsLibrary,
  BaseEvent,
  BaseGameController,
  BaseGameScene,
  BaseState,
  DeviceManager,
  DeviceManagerEvents,
  EventsEnum,
  EventsManager,
  GameApplication,
  GameComponentsHolder,
  GameConfig,
  GameFactory,
  GameProperties,
  GameScene,
  GameStates,
  GameStatus,
  Globals,
  LoadingScene,
  Orientation,
  OrientationTypes,
  PositionManager,
  Preloader,
  PreloaderEvents,
  SceneNames,
  ScreenManager,
  SlotMachineStates,
  SoundId,
  SoundManager,
  SpriteSheetFactory,
  StartScreen,
  StateHolder,
  StateMachine,
  cancelablePause,
  EventBus_default as eventBus,
  pause,
  shuffleArray
};
/*! Bundled license information:

signals/dist/signals.js:
  (** @license
   * JS Signals <http://millermedeiros.github.com/js-signals/>
   * Released under the MIT license
   * Author: Miller Medeiros
   * Version: 1.0.0 - Build: 268 (2012/11/29 05:48 PM)
   *)

howler/dist/howler.js:
  (*!
   *  howler.js v2.2.4
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   *)
  (*!
   *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
   *  
   *  howler.js v2.2.4
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   *)
*/
//# sourceMappingURL=my-pixi-coffee-pixi-game-framework.js.map
